
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>endpoint: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/endpoint/endpoints.go (100.0%)</option>
				
				<option value="file1">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/errors/error.go (100.0%)</option>
				
				<option value="file2">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/service/instrumenting.go (0.0%)</option>
				
				<option value="file3">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/service/middlewares.go (0.0%)</option>
				
				<option value="file4">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/service/service.go (99.2%)</option>
				
				<option value="file5">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/service/service_dev.go (0.0%)</option>
				
				<option value="file6">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/transport/http.go (92.8%)</option>
				
				<option value="file7">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/config/config.go (0.0%)</option>
				
				<option value="file8">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/crypto/crypto.go (76.0%)</option>
				
				<option value="file9">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/docs/openapi3.go (0.0%)</option>
				
				<option value="file10">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/mocks/db.go (62.5%)</option>
				
				<option value="file11">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/mocks/lamassuCaClient.go (37.8%)</option>
				
				<option value="file12">github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/models/dms/store/db/db.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package endpoint

import (
        "context"
        "crypto/x509"
        "math"

        "github.com/go-kit/kit/endpoint"
        "github.com/go-kit/kit/tracing/opentracing"
        "github.com/go-playground/validator/v10"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/common/dto"
        dmsenrrors "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/errors"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/service"
        stdopentracing "github.com/opentracing/opentracing-go"
)

type Endpoints struct {
        HealthEndpoint             endpoint.Endpoint
        PostCreateDMSEndpoint      endpoint.Endpoint
        PostCreateDMSFormEndpoint  endpoint.Endpoint
        PutChangeDMSStatusEndpoint endpoint.Endpoint
        DeleteDMSEndpoint          endpoint.Endpoint
        GetDMSsEndpoint            endpoint.Endpoint
        GetDMSbyIDEndpoint         endpoint.Endpoint
}

func MakeServerEndpoints(s service.Service, otTracer stdopentracing.Tracer) Endpoints <span class="cov8" title="1">{
        var healthEndpoint endpoint.Endpoint
        </span><span class="cov8" title="1">{
                healthEndpoint = MakeHealthEndpoint(s)
                healthEndpoint = opentracing.TraceServer(otTracer, "Health")(healthEndpoint)
        }</span>
        <span class="cov8" title="1">var postCreateDMSEndpoint endpoint.Endpoint
        </span><span class="cov8" title="1">{
                postCreateDMSEndpoint = MakeCreateDMSEndpoint(s)
                postCreateDMSEndpoint = opentracing.TraceServer(otTracer, "CreateDMS")(postCreateDMSEndpoint)
        }</span>
        <span class="cov8" title="1">var postCreateDMSFormEndpoint endpoint.Endpoint
        </span><span class="cov8" title="1">{
                postCreateDMSFormEndpoint = MakeCreateDMSFormEndpoint(s)
                postCreateDMSFormEndpoint = opentracing.TraceServer(otTracer, "CreateDMSForm")(postCreateDMSFormEndpoint)
        }</span>

        <span class="cov8" title="1">var getDMSsEndpoint endpoint.Endpoint
        </span><span class="cov8" title="1">{
                getDMSsEndpoint = MakeGetDMSsEndpoint(s)
                getDMSsEndpoint = opentracing.TraceServer(otTracer, "GetDMSs")(getDMSsEndpoint)
        }</span>
        <span class="cov8" title="1">var getDMSbyIDEndpoint endpoint.Endpoint
        </span><span class="cov8" title="1">{
                getDMSbyIDEndpoint = MakeGetDMSbyIDEndpoint(s)
                getDMSbyIDEndpoint = opentracing.TraceServer(otTracer, "GetDMSs")(getDMSbyIDEndpoint)
        }</span>
        <span class="cov8" title="1">var putChangeDMSStatusEndpoint endpoint.Endpoint
        </span><span class="cov8" title="1">{
                putChangeDMSStatusEndpoint = MakeChangeDMSStatusEndpoint(s)
                putChangeDMSStatusEndpoint = opentracing.TraceServer(otTracer, "ChangeDMSStatus")(putChangeDMSStatusEndpoint)
        }</span>
        <span class="cov8" title="1">var deleteDmsEndpoint endpoint.Endpoint
        </span><span class="cov8" title="1">{
                deleteDmsEndpoint = MakeDeleteDMSEndpoint(s)
                deleteDmsEndpoint = opentracing.TraceServer(otTracer, "DeleteDMS")(deleteDmsEndpoint)
        }</span>

        <span class="cov8" title="1">return Endpoints{
                HealthEndpoint:             healthEndpoint,
                PostCreateDMSEndpoint:      postCreateDMSEndpoint,
                PostCreateDMSFormEndpoint:  postCreateDMSFormEndpoint,
                PutChangeDMSStatusEndpoint: putChangeDMSStatusEndpoint,
                DeleteDMSEndpoint:          deleteDmsEndpoint,
                GetDMSsEndpoint:            getDMSsEndpoint,
                GetDMSbyIDEndpoint:         getDMSbyIDEndpoint,
        }</span>
}

func MakeHealthEndpoint(s service.Service) endpoint.Endpoint <span class="cov8" title="1">{
        return func(ctx context.Context, request interface{}) (response interface{}, err error) </span><span class="cov8" title="1">{
                healthy := s.Health(ctx)
                return HealthResponse{Healthy: healthy}, nil
        }</span>
}

func MakeCreateDMSEndpoint(s service.Service) endpoint.Endpoint <span class="cov8" title="1">{
        return func(ctx context.Context, request interface{}) (response interface{}, err error) </span><span class="cov8" title="1">{
                req := request.(dto.PostCSRRequest)
                err = ValidatetPostCSRRequest(req)
                if err != nil </span><span class="cov8" title="1">{
                        valError := dmsenrrors.ValidationError{
                                Msg: err.Error(),
                        }
                        return nil, &amp;valError
                }</span>
                <span class="cov8" title="1">dms, e := s.CreateDMS(ctx, req.Csr, req.DmsName)
                return dms, e</span>
        }
}

func MakeCreateDMSFormEndpoint(s service.Service) endpoint.Endpoint <span class="cov8" title="1">{
        return func(ctx context.Context, request interface{}) (response interface{}, err error) </span><span class="cov8" title="1">{
                req := request.(dto.PostDmsCreationFormRequest)
                err = ValidatePostDmsCreationFormRequest(req)
                if err != nil </span><span class="cov8" title="1">{
                        valError := dmsenrrors.ValidationError{
                                Msg: err.Error(),
                        }
                        return nil, &amp;valError
                }</span>
                <span class="cov8" title="1">privKey, dms, e := s.CreateDMSForm(ctx, dto.Subject(req.Subject), dto.PrivateKeyMetadata(req.KeyMetadata), req.DmsName)
                return dto.DmsCreationResponse{PrivKey: privKey, Dms: dms}, e</span>
        }
}

func MakeGetDMSsEndpoint(s service.Service) endpoint.Endpoint <span class="cov8" title="1">{
        return func(ctx context.Context, request interface{}) (response interface{}, err error) </span><span class="cov8" title="1">{
                _ = request.(GetDmsRequest)
                dmss, err := s.GetDMSs(ctx)
                return dmss, err
        }</span>
}
func MakeGetDMSbyIDEndpoint(s service.Service) endpoint.Endpoint <span class="cov8" title="1">{
        return func(ctx context.Context, request interface{}) (response interface{}, err error) </span><span class="cov8" title="1">{
                req := request.(GetDmsIDRequest)
                dmss, err := s.GetDMSbyID(ctx, req.ID)
                return dmss, err
        }</span>
}

func MakeChangeDMSStatusEndpoint(s service.Service) endpoint.Endpoint <span class="cov8" title="1">{
        return func(ctx context.Context, request interface{}) (response interface{}, err error) </span><span class="cov8" title="1">{
                req := request.(dto.PutChangeDmsStatusRequest)
                err = ValidatetPutChangeDmsStatusRequest(req)
                if err != nil </span><span class="cov8" title="1">{
                        valError := dmsenrrors.ValidationError{
                                Msg: err.Error(),
                        }
                        return nil, &amp;valError
                }</span>
                <span class="cov8" title="1">dms, err := s.UpdateDMSStatus(ctx, req.Status, req.ID, req.CAs)
                return dms, err</span>
        }
}

func MakeDeleteDMSEndpoint(s service.Service) endpoint.Endpoint <span class="cov8" title="1">{
        return func(ctx context.Context, request interface{}) (response interface{}, err error) </span><span class="cov8" title="1">{
                req := request.(DeleteCSRRequest)
                err = s.DeleteDMS(ctx, req.ID)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span> else<span class="cov8" title="1"> {
                        return "OK", err
                }</span>
        }
}

type HealthRequest struct{}

type HealthResponse struct {
        Healthy bool  `json:"healthy,omitempty"`
        Err     error `json:"err,omitempty"`
}
type GetDmsRequest struct{}

type GetDmsIDRequest struct {
        ID string
}

type GetCRTRequest struct {
        ID string
}
type PostDmsResponse struct {
        Dms dto.DMS `json:"dms,omitempty"`
        Err error   `json:"err,omitempty"`
}

type GetCRTResponse struct {
        Data *x509.Certificate
}

func ValidatetPostCSRRequest(request dto.PostCSRRequest) error <span class="cov8" title="1">{
        validate := validator.New()
        return validate.Struct(request)
}</span>

func ValidatePostDmsCreationFormRequest(request dto.PostDmsCreationFormRequest) error <span class="cov8" title="1">{
        CreateCARequestStructLevelValidation := func(sl validator.StructLevel) </span><span class="cov8" title="1">{
                req := sl.Current().Interface().(dto.PostDmsCreationFormRequest)
                switch req.KeyMetadata.KeyType </span>{
                case "RSA":<span class="cov8" title="1">
                        if math.Mod(float64(req.KeyMetadata.KeyBits), 1024) != 0 || req.KeyMetadata.KeyBits &lt; 2048 </span><span class="cov8" title="1">{
                                sl.ReportError(req.KeyMetadata.KeyBits, "bits", "Bits", "bits1024multipleAndGt2048", "")
                        }</span>
                case "EC":<span class="cov8" title="1">
                        if req.KeyMetadata.KeyBits != 224 &amp;&amp; req.KeyMetadata.KeyBits != 256 &amp;&amp; req.KeyMetadata.KeyBits != 384 </span><span class="cov8" title="1">{
                                sl.ReportError(req.KeyMetadata.KeyBits, "bits", "Bits", "bitsEcdsaMultiple", "")
                        }</span>
                }
        }

        <span class="cov8" title="1">validate := validator.New()
        validate.RegisterStructValidation(CreateCARequestStructLevelValidation, dto.PostDmsCreationFormRequest{})
        return validate.Struct(request)</span>
}

type GetPendingCSRFileResponse struct {
        Data []byte
        Err  error
}

type PostDirectCsr struct {
        CsrBase64Encoded string `json:"csr" validate:"base64"`
}

func ValidatetPutChangeDmsStatusRequest(request dto.PutChangeDmsStatusRequest) error <span class="cov8" title="1">{
        CreateCARequestStructLevelValidation := func(sl validator.StructLevel) </span><span class="cov8" title="1">{
                req := sl.Current().Interface().(dto.PutChangeDmsStatusRequest)
                switch req.Status </span>{
                case "APPROVED":<span class="cov8" title="1">
                        if req.CAs == nil </span><span class="cov8" title="1">{
                                sl.ReportError(req.CAs, "CAs", "CAs", "missingCAsList", "")
                        }</span>
                }

        }

        <span class="cov8" title="1">validate := validator.New()
        validate.RegisterStructValidation(CreateCARequestStructLevelValidation, dto.PutChangeDmsStatusRequest{})
        return validate.Struct(request)</span>
}

type PutChangeCSRsResponse struct {
        Dms dto.DMS
        Err error
}
type DeleteCSRRequest struct {
        ID string
}

type DeleteCSRResponse struct {
        Err error
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package errors

import "fmt"

type ValidationError struct {
        Msg string
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("validation error: %s", e.Msg)
}</span>

type DuplicateResourceError struct {
        ResourceType string
        ResourceId   string
}

func (e *DuplicateResourceError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("resource already exists. resource_type=%s resource_id=%s", e.ResourceType, e.ResourceId)
}</span>

type GenericError struct {
        Message    string
        StatusCode int
}

func (e *GenericError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s", e.Message)
}</span>

type ResourceNotFoundError struct {
        ResourceType string
        ResourceId   string
}

func (e *ResourceNotFoundError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("resource not found. resource_type=%s resource_id=%s", e.ResourceType, e.ResourceId)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/common/dto"

        "github.com/go-kit/kit/metrics"
)

type instrumentingMiddleware struct {
        requestCount   metrics.Counter
        requestLatency metrics.Histogram
        next           Service
}

func NewInstrumentingMiddleware(counter metrics.Counter, latency metrics.Histogram) Middleware <span class="cov0" title="0">{
        return func(next Service) Service </span><span class="cov0" title="0">{
                return &amp;instrumentingMiddleware{
                        requestCount:   counter,
                        requestLatency: latency,
                        next:           next,
                }
        }</span>
}

func (mw *instrumentingMiddleware) Health(ctx context.Context) bool <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                lvs := []string{"method", "Health", "error", "false"}
                mw.requestCount.With(lvs...).Add(1)
                mw.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds())
        }</span>(time.Now())

        <span class="cov0" title="0">return mw.next.Health(ctx)</span>
}

func (mw *instrumentingMiddleware) CreateDMS(ctx context.Context, csrBase64Encoded string, dmsName string) (dms dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                lvs := []string{"method", "CreateDMS", "error", fmt.Sprint(err != nil)}
                mw.requestCount.With(lvs...).Add(1)
                mw.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds())
        }</span>(time.Now())

        <span class="cov0" title="0">return mw.next.CreateDMS(ctx, csrBase64Encoded, dmsName)</span>
}

func (mw *instrumentingMiddleware) CreateDMSForm(ctx context.Context, subject dto.Subject, PrivateKeyMetadata dto.PrivateKeyMetadata, dmsName string) (_ string, d dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                lvs := []string{"method", "CreateDMSForm", "error", fmt.Sprint(err != nil)}
                mw.requestCount.With(lvs...).Add(1)
                mw.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds())
        }</span>(time.Now())

        <span class="cov0" title="0">return mw.next.CreateDMSForm(ctx, subject, PrivateKeyMetadata, dmsName)</span>
}

func (mw *instrumentingMiddleware) UpdateDMSStatus(ctx context.Context, status string, id string, CAList []string) (dOut dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                lvs := []string{"method", "UpdateDMSStatus", "error", "false"}
                mw.requestCount.With(lvs...).Add(1)
                mw.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds())
        }</span>(time.Now())

        <span class="cov0" title="0">return mw.next.UpdateDMSStatus(ctx, status, id, CAList)</span>
}

func (mw *instrumentingMiddleware) DeleteDMS(ctx context.Context, id string) (err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                lvs := []string{"method", "DeleteDMS", "error", fmt.Sprint(err != nil)}
                mw.requestCount.With(lvs...).Add(1)
                mw.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds())
        }</span>(time.Now())

        <span class="cov0" title="0">return mw.next.DeleteDMS(ctx, id)</span>
}

func (mw *instrumentingMiddleware) GetDMSs(ctx context.Context) (d []dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                lvs := []string{"method", "GetDMSs", "error", fmt.Sprint(err != nil)}
                mw.requestCount.With(lvs...).Add(1)
                mw.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds())
        }</span>(time.Now())

        <span class="cov0" title="0">return mw.next.GetDMSs(ctx)</span>
}
func (mw *instrumentingMiddleware) GetDMSbyID(ctx context.Context, id string) (d dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                lvs := []string{"method", "GetDMSbyID", "error", fmt.Sprint(err != nil)}
                mw.requestCount.With(lvs...).Add(1)
                mw.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds())
        }</span>(time.Now())

        <span class="cov0" title="0">return mw.next.GetDMSbyID(ctx, id)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package service

import (
        "context"
        "time"

        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/common/dto"
        "github.com/opentracing/opentracing-go"

        "github.com/go-kit/kit/log"
)

type Middleware func(Service) Service

func LoggingMiddleware(logger log.Logger) Middleware <span class="cov0" title="0">{
        return func(next Service) Service </span><span class="cov0" title="0">{
                return &amp;loggingMiddleware{
                        next:   next,
                        logger: logger,
                }
        }</span>
}

type loggingMiddleware struct {
        next   Service
        logger log.Logger
}

func (mw loggingMiddleware) Health(ctx context.Context) (healthy bool) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                mw.logger.Log(
                        "method", "Health",
                        "took", time.Since(begin),
                        "healthy", healthy,
                        "trace_id", opentracing.SpanFromContext(ctx),
                )
        }</span>(time.Now())
        <span class="cov0" title="0">return mw.next.Health(ctx)</span>
}

func (mw loggingMiddleware) CreateDMS(ctx context.Context, csrBase64Encoded string, dmsName string) (dms dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                mw.logger.Log(
                        "method", "CreateDMS",
                        "dmsName", dmsName,
                        "dmsID", dms.Id,
                        "took", time.Since(begin),
                        "trace_id", opentracing.SpanFromContext(ctx),
                        "err", err,
                )
        }</span>(time.Now())
        <span class="cov0" title="0">return mw.next.CreateDMS(ctx, csrBase64Encoded, dmsName)</span>
}

func (mw loggingMiddleware) CreateDMSForm(ctx context.Context, subject dto.Subject, PrivateKeyMetadata dto.PrivateKeyMetadata, dmsName string) (_ string, d dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                mw.logger.Log(
                        "method", "CreateDMSForm",
                        "dmsName", dmsName,
                        "subject", subject,
                        "KeyMetadata", PrivateKeyMetadata,
                        "dmsID", d.Id,
                        "took", time.Since(begin),
                        "trace_id", opentracing.SpanFromContext(ctx),
                        "err", err,
                )
        }</span>(time.Now())
        <span class="cov0" title="0">return mw.next.CreateDMSForm(ctx, subject, PrivateKeyMetadata, dmsName)</span>
}

func (mw loggingMiddleware) UpdateDMSStatus(ctx context.Context, status string, id string, CAList []string) (dOut dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                mw.logger.Log(
                        "method", "UpdateDMSStatus",
                        "id", id,
                        "status", status,
                        "dms_out", dOut,
                        "took", time.Since(begin),
                        "trace_id", opentracing.SpanFromContext(ctx),
                )
        }</span>(time.Now())
        <span class="cov0" title="0">return mw.next.UpdateDMSStatus(ctx, status, id, CAList)</span>
}

func (mw loggingMiddleware) DeleteDMS(ctx context.Context, id string) (err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                mw.logger.Log(
                        "method", "DeleteDMS",
                        "id", id,
                        "err", err,
                        "took", time.Since(begin),
                        "trace_id", opentracing.SpanFromContext(ctx),
                )
        }</span>(time.Now())
        <span class="cov0" title="0">return mw.next.DeleteDMS(ctx, id)</span>
}

func (mw loggingMiddleware) GetDMSs(ctx context.Context) (d []dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                mw.logger.Log(
                        "method", "GetDMSs",
                        "dmss", len(d),
                        "took", time.Since(begin),
                        "trace_id", opentracing.SpanFromContext(ctx),
                        "err", err,
                )
        }</span>(time.Now())
        <span class="cov0" title="0">return mw.next.GetDMSs(ctx)</span>
}
func (mw loggingMiddleware) GetDMSbyID(ctx context.Context, id string) (d dto.DMS, err error) <span class="cov0" title="0">{
        defer func(begin time.Time) </span><span class="cov0" title="0">{
                mw.logger.Log(
                        "method", "GetDMSbyID",
                        "dms_name", d.Name,
                        "dms_id", d.Id,
                        "dms_cert_SerialNumber", d.SerialNumber,
                        "dms_Authorized_CAs", d.AuthorizedCAs,
                        "dms_status", d.Status,
                        "took", time.Since(begin),
                        "trace_id", opentracing.SpanFromContext(ctx),
                        "err", err,
                )
        }</span>(time.Now())
        <span class="cov0" title="0">return mw.next.GetDMSbyID(ctx, id)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package service

import (
        "context"
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/asn1"
        "encoding/pem"
        "sync"

        "github.com/go-kit/kit/log"
        "github.com/jakehl/goid"
        lamassucaclient "github.com/lamassuiot/lamassuiot/pkg/ca/client"
        caDTO "github.com/lamassuiot/lamassuiot/pkg/ca/common/dto"
        dmserrors "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/errors"
        "github.com/lamassuiot/lamassuiot/pkg/utils"

        //devicesStore "github.com/lamassuiot/lamassuiot/pkg/device-manager/server/models/device/store"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/common/dto"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/models/dms"
        dmsstore "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/models/dms/store"
)

type Service interface {
        Health(ctx context.Context) bool
        CreateDMS(ctx context.Context, csrBase64Encoded string, dmsName string) (dto.DMS, error)
        CreateDMSForm(ctx context.Context, subject dto.Subject, PrivateKeyMetadata dto.PrivateKeyMetadata, dmsName string) (string, dto.DMS, error)
        UpdateDMSStatus(ctx context.Context, status string, id string, CAList []string) (dto.DMS, error)
        DeleteDMS(ctx context.Context, id string) error
        GetDMSs(ctx context.Context) ([]dto.DMS, error)
        GetDMSbyID(ctx context.Context, id string) (dto.DMS, error)
}

type enrollerService struct {
        mtx        sync.RWMutex
        dmsDBStore dmsstore.DB
        //        devicesDb       devicesStore.DB
        lamassuCaClient lamassucaclient.LamassuCaClient
        logger          log.Logger
}

func NewEnrollerService(dmsDbStore dmsstore.DB, lamassuCa *lamassucaclient.LamassuCaClient, logger log.Logger) Service <span class="cov8" title="1">{
        return &amp;enrollerService{
                dmsDBStore:      dmsDbStore,
                lamassuCaClient: *lamassuCa,
                logger:          logger,
        }
}</span>

func (s *enrollerService) Health(ctx context.Context) bool <span class="cov8" title="1">{
        return true
}</span>

func (s *enrollerService) CreateDMS(ctx context.Context, csrBase64Encoded string, dmsName string) (dto.DMS, error) <span class="cov8" title="1">{

        //csrBase64Encoded
        decodedCsr, _ := utils.DecodeB64(csrBase64Encoded)

        p, _ := pem.Decode([]byte(decodedCsr))

        csr, _ := x509.ParseCertificateRequest(p.Bytes)

        keyType, keyBits := getPublicKeyInfo(csr)

        d := dto.DMS{
                Id:        goid.NewV4UUID().String(),
                Name:      dmsName,
                CsrBase64: csrBase64Encoded,
                Status:    dms.PendingStatus,
                KeyMetadata: dto.PrivateKeyMetadataWithStregth{
                        KeyType: keyType,
                        KeyBits: keyBits,
                },

                EnrolledDevices: 0,
        }

        dmsId, _ := s.dmsDBStore.Insert(ctx, d)

        return s.dmsDBStore.SelectByID(ctx, dmsId)
}</span>

func (s *enrollerService) CreateDMSForm(ctx context.Context, subject dto.Subject, PrivateKeyMetadata dto.PrivateKeyMetadata, dmsName string) (string, dto.DMS, error) <span class="cov8" title="1">{
        subj := pkix.Name{
                CommonName:         subject.CN,
                Country:            []string{subject.C},
                Province:           []string{subject.ST},
                Locality:           []string{subject.L},
                Organization:       []string{subject.O},
                OrganizationalUnit: []string{subject.OU},
        }

        if PrivateKeyMetadata.KeyType == "RSA" </span><span class="cov8" title="1">{
                privKey, _ := rsa.GenerateKey(rand.Reader, PrivateKeyMetadata.KeyBits)
                csrBytes, _ := generateCSR(ctx, PrivateKeyMetadata.KeyType, PrivateKeyMetadata.KeyBits, privKey, subj)
                csrEncoded := pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE REQUEST", Bytes: csrBytes})

                privkey_bytes := x509.MarshalPKCS1PrivateKey(privKey)
                privkey_pem := string(pem.EncodeToMemory(
                        &amp;pem.Block{
                                Type:  "RSA PRIVATE KEY",
                                Bytes: privkey_bytes,
                        },
                ))
                privkey_pemByte := utils.EncodeB64([]byte(privkey_pem))
                csr, _ := s.CreateDMS(ctx, string(utils.EncodeB64(csrEncoded)), dmsName)

                return string(privkey_pemByte), csr, nil

        }</span> else<span class="cov8" title="1"> {
                var priv *ecdsa.PrivateKey
                switch PrivateKeyMetadata.KeyBits </span>{
                case 224:<span class="cov8" title="1">
                        priv, _ = ecdsa.GenerateKey(elliptic.P224(), rand.Reader)</span>
                case 256:<span class="cov8" title="1">
                        priv, _ = ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</span>
                case 384:<span class="cov8" title="1">
                        priv, _ = ecdsa.GenerateKey(elliptic.P384(), rand.Reader)</span>
                }
                <span class="cov8" title="1">privkey_bytesm, _ := x509.MarshalPKCS8PrivateKey(priv)
                privkey_pem := string(pem.EncodeToMemory(
                        &amp;pem.Block{
                                Type:  "PRIVATE KEY",
                                Bytes: privkey_bytesm,
                        },
                ))
                privkey_pemByte := utils.EncodeB64([]byte(privkey_pem))
                csrBytes, _ := generateCSR(ctx, PrivateKeyMetadata.KeyType, PrivateKeyMetadata.KeyBits, priv, subj)
                csrEncoded := pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE REQUEST", Bytes: csrBytes})
                csr, _ := s.CreateDMS(ctx, string(utils.EncodeB64(csrEncoded)), dmsName)

                return string(privkey_pemByte), csr, nil</span>

        }
}

func generateCSR(ctx context.Context, keyType string, keyBits int, priv interface{}, subj pkix.Name) ([]byte, error) <span class="cov8" title="1">{
        var signingAlgorithm x509.SignatureAlgorithm
        if keyType == "EC" </span><span class="cov8" title="1">{
                signingAlgorithm = x509.ECDSAWithSHA512
        }</span> else<span class="cov8" title="1"> {
                signingAlgorithm = x509.SHA512WithRSA
        }</span>
        <span class="cov8" title="1">rawSubj := subj.ToRDNSequence()
        /*rawSubj = append(rawSubj, []pkix.AttributeTypeAndValue{
                {Type: oidEmailAddress, Value: emailAddress},
        })*/

        asn1Subj, _ := asn1.Marshal(rawSubj)
        template := x509.CertificateRequest{
                RawSubject: asn1Subj,
                //EmailAddresses:     []string{emailAddress},
                SignatureAlgorithm: signingAlgorithm,
        }
        csrBytes, err := x509.CreateCertificateRequest(rand.Reader, &amp;template, priv)
        return csrBytes, err</span>
}

func (s *enrollerService) UpdateDMSStatus(ctx context.Context, DMSstatus string, id string, CAList []string) (dto.DMS, error) <span class="cov8" title="1">{
        var err error
        var d dto.DMS
        prevDms, err := s.dmsDBStore.SelectByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return dto.DMS{}, err
        }</span>

        <span class="cov8" title="1">switch status := DMSstatus; status </span>{
        case dms.ApprovedStatus:<span class="cov8" title="1">
                if prevDms.Status == dms.PendingStatus </span><span class="cov8" title="1">{
                        b, _ := utils.DecodeB64(prevDms.CsrBase64)
                        csrBytes, _ := pem.Decode([]byte(b))
                        csr, _ := x509.ParseCertificateRequest(csrBytes.Bytes)
                        crt, _ := s.ApprobeCSR(ctx, id, csr)
                        err = s.dmsDBStore.InsertAuthorizedCAs(ctx, id, CAList)
                        if err != nil </span><span class="cov8" title="1">{
                                return dto.DMS{}, err
                        }</span>
                        <span class="cov8" title="1">d, _ = s.dmsDBStore.UpdateByID(ctx, id, dms.ApprovedStatus, utils.InsertNth(utils.ToHexInt(crt.SerialNumber), 2), "")

                        var cb []byte
                        cb = append(cb, crt.Raw...)
                        certificate := pem.Block{Type: "CERTIFICATE", Bytes: cb}
                        cert := pem.EncodeToMemory(&amp;certificate)

                        d.CerificateBase64 = string(utils.EncodeB64(cert))</span>

                } else<span class="cov8" title="1"> {
                        return dto.DMS{}, &amp;dmserrors.GenericError{
                                Message:    "The DMS Status is not PENDING_APPROVAL",
                                StatusCode: 412,
                        }
                }</span>
        case dms.RevokedStatus:<span class="cov8" title="1">
                if prevDms.Status == dms.ApprovedStatus </span><span class="cov8" title="1">{
                        d, _ = s.dmsDBStore.UpdateByID(ctx, id, dms.RevokedStatus, prevDms.SerialNumber, "")
                        _ = s.RevokeCert(ctx, prevDms.SerialNumber)
                        _ = s.dmsDBStore.DeleteAuthorizedCAs(ctx, id)
                }</span> else<span class="cov8" title="1"> {
                        return dto.DMS{}, &amp;dmserrors.GenericError{
                                Message:    "The DMS Status is not APPROVED",
                                StatusCode: 412,
                        }
                }</span>
        case dms.DeniedStatus:<span class="cov8" title="1">
                if prevDms.Status == dms.PendingStatus </span><span class="cov8" title="1">{
                        d, _ = s.dmsDBStore.UpdateByID(ctx, id, dms.DeniedStatus, "", "")
                }</span> else<span class="cov8" title="1"> {
                        return dto.DMS{}, &amp;dmserrors.GenericError{
                                Message:    "The DMS Status is not PENDING_APPROVAL",
                                StatusCode: 412,
                        }
                }</span>
        default:<span class="cov8" title="1">
                return dto.DMS{}, &amp;dmserrors.GenericError{
                        Message:    "The Status is PENDING_APPROVAL",
                        StatusCode: 412,
                }</span>
        }

        <span class="cov8" title="1">return d, nil</span>
}

func (s *enrollerService) RevokeCert(ctx context.Context, serialToRevoke string) error <span class="cov8" title="1">{
        caType, err := caDTO.ParseCAType("dmsenroller")
        // revocar llamando a lamassu CA
        err = s.lamassuCaClient.RevokeCert(ctx, caType, "Lamassu-DMS-Enroller", serialToRevoke)
        return err
}</span>

func (s *enrollerService) ApprobeCSR(ctx context.Context, id string, csr *x509.CertificateRequest) (*x509.Certificate, error) <span class="cov8" title="1">{
        caType, _ := caDTO.ParseCAType("dmsenroller")
        crt, _, _ := s.lamassuCaClient.SignCertificateRequest(ctx, caType, "Lamassu-DMS-Enroller", csr, true)

        return crt, nil
}</span>

func (s *enrollerService) DeleteDMS(ctx context.Context, id string) error <span class="cov8" title="1">{
        d, err := s.dmsDBStore.SelectByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if d.Status == dms.DeniedStatus || d.Status == dms.RevokedStatus </span><span class="cov8" title="1">{
                _ = s.dmsDBStore.Delete(ctx, id)
                if d.Status == dms.RevokedStatus </span><span class="cov8" title="1">{
                        _ = s.dmsDBStore.DeleteAuthorizedCAs(ctx, id)
                }</span>
        } else<span class="cov8" title="1"> {
                return &amp;dmserrors.GenericError{
                        Message:    "The DMS Status is " + d.Status,
                        StatusCode: 412,
                }
        }</span>
        <span class="cov8" title="1">return err</span>
}
func (s *enrollerService) GetDMSs(ctx context.Context) ([]dto.DMS, error) <span class="cov8" title="1">{
        caType, err := caDTO.ParseCAType("dmsenroller")
        d, err := s.dmsDBStore.SelectAll(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return []dto.DMS{}, err
        }</span>
        <span class="cov8" title="1">var dmsList []dto.DMS = make([]dto.DMS, 0)
        for _, item := range d </span><span class="cov8" title="1">{
                lamassuCert, _ := s.lamassuCaClient.GetCert(ctx, caType, "Lamassu-DMS-Enroller", item.SerialNumber)
                item.Subject = dto.Subject{
                        C:  lamassuCert.Subject.C,
                        ST: lamassuCert.Subject.ST,
                        L:  lamassuCert.Subject.L,
                        O:  lamassuCert.Subject.O,
                        OU: lamassuCert.Subject.OU,
                        CN: lamassuCert.Subject.CN,
                }
                item.CerificateBase64 = lamassuCert.CertContent.CerificateBase64
                //        item.EnrolledDevices, err = s.devicesDb.CountDevicesByDmsId(ctx, item.Id)
                if item.Status == "APPROVED" </span><span class="cov8" title="1">{
                        CAs, _ := s.dmsDBStore.SelectByDMSIDAuthorizedCAs(ctx, item.Id)
                        for _, ca := range CAs </span><span class="cov8" title="1">{
                                item.AuthorizedCAs = append(item.AuthorizedCAs, ca.CaName)
                        }</span>
                }
                <span class="cov8" title="1">dmsList = append(dmsList, item)</span>
        }

        <span class="cov8" title="1">return dmsList, nil</span>
}

func (s *enrollerService) GetDMSbyID(ctx context.Context, id string) (dto.DMS, error) <span class="cov8" title="1">{
        caType, err := caDTO.ParseCAType("dmsenroller")
        d, err := s.dmsDBStore.SelectByID(ctx, id)
        //d.EnrolledDevices, err = s.devicesDb.CountDevicesByDmsId(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return dto.DMS{}, err
        }</span>
        <span class="cov8" title="1">lamassuCert, _ := s.lamassuCaClient.GetCert(ctx, caType, "Lamassu-DMS-Enroller", d.SerialNumber)
        d.Subject = dto.Subject{
                C:  lamassuCert.Subject.C,
                ST: lamassuCert.Subject.ST,
                L:  lamassuCert.Subject.L,
                O:  lamassuCert.Subject.O,
                OU: lamassuCert.Subject.OU,
                CN: lamassuCert.Subject.CN,
        }
        d.CerificateBase64 = lamassuCert.CertContent.CerificateBase64
        if d.Status == "APPROVED" </span><span class="cov8" title="1">{
                CAs, _ := s.dmsDBStore.SelectByDMSIDAuthorizedCAs(ctx, d.Id)
                for _, ca := range CAs </span><span class="cov8" title="1">{
                        d.AuthorizedCAs = append(d.AuthorizedCAs, ca.CaName)
                }</span>
        }
        <span class="cov8" title="1">return d, nil</span>
}

func getPublicKeyInfo(cert *x509.CertificateRequest) (string, int) <span class="cov8" title="1">{
        key := cert.PublicKeyAlgorithm.String()
        var keyBits int
        switch key </span>{
        case "RSA":<span class="cov8" title="1">
                keyBits = cert.PublicKey.(*rsa.PublicKey).N.BitLen()
                return "RSA", keyBits</span>
        case "ECDSA":<span class="cov8" title="1">
                keyBits = cert.PublicKey.(*ecdsa.PublicKey).Params().BitSize
                return "EC", keyBits</span>
        }

        <span class="cov0" title="0">return "UNKOWN_KEY_TYPE", -1</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package service

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "strconv"
        "testing"

        "github.com/go-kit/log"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/common/dto"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/mocks"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/models/dms"
        "github.com/lamassuiot/lamassuiot/pkg/utils"
)

func TestUpdateDMSStatus(t *testing.T) <span class="cov0" title="0">{
        srv, ctx := setup(t)

        testCases := []struct {
                name      string
                DMSstatus string
                id        string
                ret       error
        }{
                {"Status aproved prevDMS pending error update", dms.ApprovedStatus, "2", errors.New("Error Update By ID")},
                {"Status Revoked prevDMS not approved", dms.RevokedStatus, "2", nil},
                {"Status Revoked prevDMS not approved", dms.ApprovedStatus, "2", nil},
                {"Status Default", "", "2", nil},
                {"Error getting certificate Revoked", dms.RevokedStatus, "1", errors.New("Error revoking certificate")},
                {"Error approving cert", dms.ApprovedStatus, "2", errors.New("Error revoking certificate")},
                {"Error Parse Certificate Request", dms.ApprovedStatus, "2", errors.New("asn1: structure error: tags don't match (2 vs {class:2 tag:0 length:3 isCompound:true}) {optional:false explicit:false application:false private:false defaultValue:&lt;nil&gt; tag:&lt;nil&gt; stringType:0 timeType:0 set:false omitEmpty:false} int @2")},

                {"Error revoking cert", dms.RevokedStatus, "1", errors.New("Error revoking certificate")},
                {"Correct Approved", dms.ApprovedStatus, "1", nil},
                {"Correct Revoked", dms.RevokedStatus, "1", nil},
                {"Correct Denied", dms.DeniedStatus, "1", nil},
                {"Error finding ID", "", "1", errors.New("Error Select By ID")},
                {"Error getting certificate Approved", dms.ApprovedStatus, "1", errors.New("Error Update By ID")},

                {"Error getting certificate Denied", dms.DeniedStatus, "4", errors.New("Error Update By ID")},
                {"Error revoked update", dms.RevokedStatus, "1", errors.New("Error Update By ID")},
                {"Error denied update", dms.DeniedStatus, "2", errors.New("Error Update By ID")},
        }
        for _, tc := range testCases </span><span class="cov0" title="0">{

                t.Run(fmt.Sprintf("Testing %s", tc.name), func(t *testing.T) </span><span class="cov0" title="0">{

                        if tc.name == "Status aproved prevDMS pending error update" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBUpdateByID", true)
                                ctx = context.WithValue(ctx, "RevokeCertShouldFail", false)
                                ctx = context.WithValue(ctx, "RevokeCertShouldFail", false)
                                ctx = context.WithValue(ctx, "SignCertificateRequestFail", false)
                                ctx = context.WithValue(ctx, "DBCsrBase64", true)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Error getting certificate Revoked" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBUpdateByID", false)
                                ctx = context.WithValue(ctx, "RevokeCertShouldFail", true)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Error finding ID" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", true)
                                ctx = context.WithValue(ctx, "DBUpdateByID", false)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Error getting certificate Approved" || tc.name == "Error getting certificate Revoked" || tc.name == "Error getting certificate Denied" || tc.name == "Error denied update" || tc.name == "Error revoked update" || tc.name == "tatus Revoked prevDMS not approved" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBUpdateByID", true)
                                ctx = context.WithValue(ctx, "SignCertificateRequestFail", false)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Error updating certificate Revoked" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBUpdateByID", true)
                                ctx = context.WithValue(ctx, "SignCertificateRequestFail", false)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Error revoking cert" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBUpdateByID", false)
                                ctx = context.WithValue(ctx, "RevokeCertShouldFail", true)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Error approving cert" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBUpdateByID", false)
                                ctx = context.WithValue(ctx, "RevokeCertShouldFail", false)
                                ctx = context.WithValue(ctx, "SignCertificateRequestFail", true)
                                ctx = context.WithValue(ctx, "DBCsrBase64", true)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Status Revoked prevDMS not approved" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBUpdateByID", false)
                                ctx = context.WithValue(ctx, "RevokeCertShouldFail", false)
                                ctx = context.WithValue(ctx, "SignCertificateRequestFail", false)
                                ctx = context.WithValue(ctx, "DBCsrBase64", true)
                        }</span> else<span class="cov0" title="0"> {
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBUpdateByID", false)
                                ctx = context.WithValue(ctx, "RevokeCertShouldFail", false)
                                ctx = context.WithValue(ctx, "SignCertificateRequestFail", false)
                                ctx = context.WithValue(ctx, "DBCsrBase64", false)
                        }</span>
                        //TODO: test with CA list
                        <span class="cov0" title="0">_, err := srv.UpdateDMSStatus(ctx, tc.DMSstatus, tc.id, []string{"IkerCA"})
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() != tc.ret.Error() </span><span class="cov0" title="0">{
                                        t.Errorf("Got result is %s; want %s", err, tc.ret)
                                }</span>
                        }
                })
        }
}
func TestCreateDMS(t *testing.T) <span class="cov0" title="0">{
        srv, ctx := setup(t)

        csrRSA := "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ2pqQ0NBWFlDQVFBd1NURUxNQWtHQTFVRUJoTUNSVk14Q2pBSUJnTlZCQWdNQVVFeENqQUlCZ05WQkFjTQpBVUV4Q2pBSUJnTlZCQW9NQVVFeENqQUlCZ05WQkFzTUFVRXhDakFJQmdOVkJBTU1BVUV3Z2dFaU1BMEdDU3FHClNJYjNEUUVCQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUURDaFUxRFROckI0a2JTaVpjQjBMaHhUQ2dPYXlQUUU0VzkKT2N1MFBpczBybUliZnM2T2pERk5qcUY5dlhOcFlUSGhtL3FaTVZTWEZYZjM4VDBJS3NmU2lCYm5aa0pYWWc0NgptY2tLY1VkQ0VsUy8wK3RYaDh6Slo3QXNsV0Z2eXFLek5nUVJCcnhJQ0RVOTdVWXJ6eWk3ajVOSUJ2OHJvRld4CjVJOUNXUEpEQ00vRUFHMHVldjZQNVQzN2dKUzlFcnZXeERmWDVJL3hxRnZEQnpsV0VqbytFZ1piM3daSEt5d3QKMUVaVHBET1NKY29VeXZnWmFwUFF6U2JDZVdUL3ZlRW8rem5pUlk5SThFRlJhNm9DWDNCbVc4Snh2V2FSOVd3YQpnVUZ4cFM5OHdJN0JwSVJUeFgwdk9oMXZlUlBjWmRsVmFMZlJQb1BuV1BkdHAwckFDdXB6QWdNQkFBR2dBREFOCkJna3Foa2lHOXcwQkFRc0ZBQU9DQVFFQUllbTV5YnpVR1VvSk9yUjc1bW5COGZNUmVBWi9NalRVamYwem0xQjQKeGo4U1FMYTI2djU2ZkxOYkZ6NTlaaDlJa0J2U1AyNWNRTm5JU1lZT3RxejZLakJzcEVVQnNKaFVKcTNRNXpybgo3WVVoZnN2NWIzN0h2Y3h6akpvWW05NlZiU2FwQk5RWStGbjJ3R3NhZ1Zucktoalk0REdMM0lKQmlicmJvcEg2ClJwaFJRMWwyeXcwbUEybG9jK0hEZ1VwVTR4bXRpangvbHZmdHkzYVdwelBmV3pOWFRVYkEwNTFGY3hEQWh0SlkKbEd5WUxKSk1XQ08rL3NlUkxLSWFrZTFNeFR5Nzd0WVJ3MUNkVkJWWWFIbU8xM2k3ek8zYWVxdzloaGNHcWhyUQpXSWlYQ2lRdm9GN25oSmRvOEdmbkV5L1hKWk54LzQzbFVxUFcrekNhaWlsa2h3PT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUgUkVRVUVTVC0tLS0t"
        csrError := "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNURENDQWZPZ0F3SUJBZ0lVZnRXcTVObnpXZHUrSHk2S1RTMmpWazcybzRjd0NnWUlLb1pJemowRUF3SXcKY3pFTE1Ba0dBMVVFQmhNQ1JWTXhFVEFQQmdOVkJBZ1RDRWRwY0hWNmEyOWhNUkV3RHdZRFZRUUhFd2hCY25KaApjMkYwWlRFaE1BNEdBMVVFQ2hNSFV5NGdRMjl2Y0RBUEJnTlZCQW9UQ0V4TFV5Qk9aWGgwTVJzd0dRWURWUVFECkV4Sk1TMU1nVG1WNGRDQlNiMjkwSUVOQklETXdJQmNOTWpJd01USXdNVEV3TWpJMVdoZ1BNakExTWpBeE1UTXgKTVRBeU5UVmFNSE14Q3pBSkJnTlZCQVlUQWtWVE1SRXdEd1lEVlFRSUV3aEhhWEIxZW10dllURVJNQThHQTFVRQpCeE1JUVhKeVlYTmhkR1V4SVRBT0JnTlZCQW9UQjFNdUlFTnZiM0F3RHdZRFZRUUtFd2hNUzFNZ1RtVjRkREViCk1Ca0dBMVVFQXhNU1RFdFRJRTVsZUhRZ1VtOXZkQ0JEUVNBek1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMEQKQVFjRFFnQUU1aTFxZnlZU2xLaWt3SDhGZkhvQWxVWE44RlE3aE1OMERaTk8vVzdiSE44NVFpZ09ZeVQ1bWNYMgpXbDJtSTVEL0xQT1BKd0l4N1ZZcmxZU1BMTm5ndjZOak1HRXdEZ1lEVlIwUEFRSC9CQVFEQWdFR01BOEdBMVVkCkV3RUIvd1FGTUFNQkFmOHdIUVlEVlIwT0JCWUVGUGRURSs3a0k2MXFXSHFtUktZai9OaElIS01lTUI4R0ExVWQKSXdRWU1CYUFGUGRURSs3a0k2MXFXSHFtUktZai9OaElIS01lTUFvR0NDcUdTTTQ5QkFNQ0EwY0FNRVFDSUI2QQptZStjRzQ0MjBpNE5QZ1ZwWVRHN3hFN2lvbG0xOXhqRC9PcS9TeWt0QWlBaWRBK2JTanpvVHZxckRieDBqaHBiCmJpTnFycHZJY255TEY1MXQ5cHdBL1E9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0t"
        //csrECDSA := "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQml6Q0I3Z0lCQURCSk1Rc3dDUVlEVlFRR0V3SkZVekVLTUFnR0ExVUVDQXdCUVRFS01BZ0dBMVVFQnd3QgpRVEVLTUFnR0ExVUVDZ3dCUVRFS01BZ0dBMVVFQ3d3QlFURUtNQWdHQTFVRUF3d0JRVENCbXpBUUJnY3Foa2pPClBRSUJCZ1VyZ1FRQUl3T0JoZ0FFQWFSaC9nZFpMMGo2ZGZ5d2NLaU1HSkN3RTVvVk1BWVpZV3BHa2gyUWFuMFYKOWR3ZjhQUS9wZnlMVGpEeVFCVVVxckxOQlQ5ZEFPcFczZHYvZlV4UFVnZWJBQVhSUVBVMUVLV2NNb2pZWTkvaQptVXBQMnlsNHVHUUdBQXlUQzdmUG5NbzNZVkd5cU5uZ2ZQK0N5WE1INnoxUGtGZk1xcFZHM0Z0dGhnSmZvcWt2CnNabWFvQUF3Q2dZSUtvWkl6ajBFQXdJRGdZc0FNSUdIQWtFSm9lS3E2Y1greU9xVk5lQzIyZ1IzaGFaSjlqMm4KSkR6bkVvT3E4Y29qT1h5M2J1MTJDUlptWTU5UUFFK1JJRTJiWk56TGtqMWJQcE1jUlBad0s1R0l5UUpDQU5lMwoxUnAyTUVKS0NsNitnMHk4WlpHU0VwUmdoaCtueUpuNXJ3OTZzVEcyQVlpV0NVTWxvVSt1eGdieDBocDdKNkR3Cm55QVZrbnE3bkVGT2thNkZLdzhFCi0tLS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQ=="

        testCases := []struct {
                name    string
                csr     string
                dmsName string
                ret     error
        }{
                //{"Correct ECDSA", csrECDSA, "a", errors.New("Error")},
                {"Error DecodeB64", "\x00\x00\x00", "a", errors.New("illegal base64 data at input byte 0")},
                {"Correct RSA", csrRSA, "a", errors.New("Error")},

                {"Error Insert", csrRSA, "a", errors.New("Error Insert")},
                {"Error Parse Certificate Request", csrError, "a", errors.New("asn1: structure error: tags don't match (2 vs {class:2 tag:0 length:3 isCompound:true}) {optional:false explicit:false application:false private:false defaultValue:&lt;nil&gt; tag:&lt;nil&gt; stringType:0 timeType:0 set:false omitEmpty:false} int @2")},
        }
        for _, tc := range testCases </span><span class="cov0" title="0">{

                t.Run(fmt.Sprintf("Testing %s", tc.name), func(t *testing.T) </span><span class="cov0" title="0">{

                        if tc.name == "Error Insert" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBInsert", true)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Error Parse Certificate Request" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBInsert", false)
                        }</span> else<span class="cov0" title="0"> {
                                ctx = context.WithValue(ctx, "DBInsert", false)
                        }</span>
                        <span class="cov0" title="0">_, err := srv.CreateDMS(ctx, tc.csr, tc.dmsName)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() != tc.ret.Error() </span><span class="cov0" title="0">{
                                        t.Errorf("Got result is %s; want %s", err, tc.ret)
                                }</span>
                        }
                })
        }
}
func TestGetDMSs(t *testing.T) <span class="cov0" title="0">{
        srv, ctx := setup(t)

        testCases := []struct {
                name string
                ret  error
        }{

                {"Correct", errors.New("Error Select All")},
                {"Incorrect", errors.New("Error Select All")},
        }
        for _, tc := range testCases </span><span class="cov0" title="0">{

                t.Run(fmt.Sprintf("Testing %s", tc.name), func(t *testing.T) </span><span class="cov0" title="0">{

                        if tc.name == "Incorrect" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectAll", true)
                        }</span> else<span class="cov0" title="0"> {
                                ctx = context.WithValue(ctx, "DBSelectAll", false)
                                ctx = context.WithValue(ctx, "GetCertFail", false)

                        }</span>
                        <span class="cov0" title="0">_, err := srv.GetDMSs(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() != tc.ret.Error() </span><span class="cov0" title="0">{
                                        t.Errorf("Got result is %s; want %s", err, tc.ret)
                                }</span>
                        }
                })
        }
}

func TestCreateDMSForm(t *testing.T) <span class="cov0" title="0">{
        srv, ctx := setup(t)

        subject := dto.Subject{
                C:  "C",
                CN: "CN",
                O:  "O",
                L:  "L",
                OU: "OU",
                ST: "ST",
        }

        RSAkey := dto.PrivateKeyMetadata{
                KeyType: "RSA",
                KeyBits: 4096,
        }
        ECkey224 := dto.PrivateKeyMetadata{
                KeyType: "EC",
                KeyBits: 224,
        }
        ECkeyUnsupported := dto.PrivateKeyMetadata{
                KeyType: "EC",
                KeyBits: 4096,
        }

        ECkey256 := dto.PrivateKeyMetadata{
                KeyType: "EC",
                KeyBits: 256,
        }
        ECkey384 := dto.PrivateKeyMetadata{
                KeyType: "EC",
                KeyBits: 384,
        }
        ECkey521 := dto.PrivateKeyMetadata{
                KeyType: "EC",
                KeyBits: 521,
        }
        Undeclaredkey := dto.PrivateKeyMetadata{
                KeyType: "fgd",
                KeyBits: 4096,
        }
        testCases := []struct {
                name    string
                subject dto.Subject
                key     dto.PrivateKeyMetadata
                url     string
                dmsName string
                ret     error
        }{
                {"RSA Key", subject, RSAkey, "a", "A", nil},
                {"EC Key Error", subject, ECkey224, "a", "A", errors.New("x509: requested SignatureAlgorithm does not match private key type")},
                {"EC Key Error", subject, ECkey256, "a", "A", errors.New("x509: requested SignatureAlgorithm does not match private key type")},
                {"EC Key Error", subject, ECkey384, "a", "A", errors.New("x509: requested SignatureAlgorithm does not match private key type")},
                {"EC Key Error", subject, ECkey521, "a", "A", errors.New("x509: requested SignatureAlgorithm does not match private key type")},
                {"EC Key Unsupported", subject, ECkeyUnsupported, "a", "A", errors.New("Unsupported key length")},
                {"Undeclared Key", subject, Undeclaredkey, "a", "A", errors.New("Invalid key format")},
                {"CreateDMS", subject, RSAkey, "a", "A", errors.New("Invalid key format")},
        }
        for _, tc := range testCases </span><span class="cov0" title="0">{

                t.Run(fmt.Sprintf("Testing %s", tc.name), func(t *testing.T) </span><span class="cov0" title="0">{

                        if tc.name == "Error Insert" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBInsert", true)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Error Parse Certificate Request" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBInsert", false)
                        }</span> else<span class="cov0" title="0"> {
                                ctx = context.WithValue(ctx, "DBInsert", false)
                        }</span>
                        <span class="cov0" title="0">_, _, err := srv.CreateDMSForm(ctx, tc.subject, tc.key, tc.dmsName)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() != tc.ret.Error() </span><span class="cov0" title="0">{
                                        t.Errorf("Got result is %s; want %s", err, tc.ret)
                                }</span>
                        }
                })
        }
}

func TestDeleteDMS(t *testing.T) <span class="cov0" title="0">{
        srv, ctx := setup(t)

        testCases := []struct {
                name string
                id   string
                ret  error
        }{

                {"Correct", "1", nil},
                {"Error finding ID", "1", errors.New("Error Select By ID")},
                {"Error Delete", "3", errors.New("Error Delete")},
        }
        for _, tc := range testCases </span><span class="cov0" title="0">{

                t.Run(fmt.Sprintf("Testing %s", tc.name), func(t *testing.T) </span><span class="cov0" title="0">{

                        if tc.name == "Error finding ID" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", true)
                                ctx = context.WithValue(ctx, "DBDelete", false)
                        }</span> else<span class="cov0" title="0"> if tc.name == "Error Delete" </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBDelete", true)
                        }</span> else<span class="cov0" title="0"> {
                                ctx = context.WithValue(ctx, "DBSelectByID", false)
                                ctx = context.WithValue(ctx, "DBDelete", false)
                        }</span>
                        <span class="cov0" title="0">err := srv.DeleteDMS(ctx, tc.id)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() != tc.ret.Error() </span><span class="cov0" title="0">{
                                        t.Errorf("Got result is %s; want %s", err, tc.ret)
                                }</span>
                        }
                })
        }
}

func TestHealth(t *testing.T) <span class="cov0" title="0">{
        srv, ctx := setup(t)
        type testCasesHealth struct {
                name string
                ret  bool
        }
        cases := []testCasesHealth{
                {"Correct", true},
        }
        for _, tc := range cases </span><span class="cov0" title="0">{

                out := srv.Health(ctx)
                if tc.ret != out </span><span class="cov0" title="0">{
                        t.Errorf("Expected '%s', but got '%s'", strconv.FormatBool(tc.ret), strconv.FormatBool(out))
                }</span>

        }
}

func setup(t *testing.T) (Service, context.Context) <span class="cov0" title="0">{
        t.Helper()

        buf := &amp;bytes.Buffer{}
        logger := log.NewJSONLogger(buf)
        ctx := context.Background()
        ctx = context.WithValue(ctx, utils.LamassuLoggerContextKey, logger)

        dmsDb, _ := mocks.NewDB(t)

        lamassuCaClient, _ := mocks.NewLamassuCaClientMock(logger)

        srv := NewEnrollerService(dmsDb, &amp;lamassuCaClient, logger)
        return srv, ctx
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package transport

import (
        "context"
        "crypto/x509"
        "encoding/json"
        "net/http"

        "github.com/gorilla/mux"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/common/dto"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/endpoint"
        dmsErrors "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/errors"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/service"
        "github.com/lamassuiot/lamassuiot/pkg/utils"

        "github.com/go-kit/kit/log"
        "github.com/go-kit/kit/tracing/opentracing"
        "github.com/go-kit/kit/transport"
        httptransport "github.com/go-kit/kit/transport/http"

        stdopentracing "github.com/opentracing/opentracing-go"
)

type errorer interface {
        error() error
}

func InvalidJsonFormat() error <span class="cov8" title="1">{
        return &amp;dmsErrors.GenericError{
                Message:    "Invalid JSON format",
                StatusCode: 400,
        }
}</span>
func ErrMissingDMSStatus() error <span class="cov8" title="1">{
        return &amp;dmsErrors.GenericError{
                Message:    "DMS status not specified",
                StatusCode: 400,
        }
}</span>
func HTTPToContext(logger log.Logger) httptransport.RequestFunc <span class="cov8" title="1">{
        return func(ctx context.Context, req *http.Request) context.Context </span><span class="cov8" title="1">{
                // Try to join to a trace propagated in `req`.
                uberTraceId := req.Header.Values("Uber-Trace-Id")
                if uberTraceId != nil </span><span class="cov0" title="0">{
                        logger = log.With(logger, "span_id", uberTraceId)
                }</span> else<span class="cov8" title="1"> {
                        span := stdopentracing.SpanFromContext(ctx)
                        logger = log.With(logger, "span_id", span)
                }</span>
                <span class="cov8" title="1">return context.WithValue(ctx, utils.LamassuLoggerContextKey, logger)</span>
        }
}
func MakeHTTPHandler(s service.Service, logger log.Logger, otTracer stdopentracing.Tracer) http.Handler <span class="cov8" title="1">{
        r := mux.NewRouter()
        e := endpoint.MakeServerEndpoints(s, otTracer)
        options := []httptransport.ServerOption{
                httptransport.ServerErrorHandler(transport.NewLogErrorHandler(logger)),
                httptransport.ServerErrorEncoder(encodeError),
                // httptransport.ServerBefore(jwt.HTTPToContext()),
        }

        r.Methods("GET").Path("/v1/health").Handler(httptransport.NewServer(
                e.HealthEndpoint,
                decodeHealthRequest,
                encodeResponse,
                append(
                        options,
                        httptransport.ServerBefore(opentracing.HTTPToContext(otTracer, "Health", logger)),
                        httptransport.ServerBefore(HTTPToContext(logger)),
                )...,
        ))

        r.Methods("POST").Path("/v1/{name}").Handler(httptransport.NewServer(
                e.PostCreateDMSEndpoint,
                decodePostCSRRequest,
                encodeResponse,
                append(
                        options,
                        httptransport.ServerBefore(opentracing.HTTPToContext(otTracer, "PostCSR", logger)),
                        httptransport.ServerBefore(HTTPToContext(logger)),
                )...,
        ))
        r.Methods("POST").Path("/v1/{name}/form").Handler(httptransport.NewServer(
                e.PostCreateDMSFormEndpoint,
                decodePostCreateDMSFormRequest,
                encodeResponse,
                append(
                        options,
                        httptransport.ServerBefore(opentracing.HTTPToContext(otTracer, "PostCSRForm", logger)),
                        httptransport.ServerBefore(HTTPToContext(logger)),
                )...,
        ))

        r.Methods("GET").Path("/v1/").Handler(httptransport.NewServer(
                e.GetDMSsEndpoint,
                decodeGetDMSsRequest,
                encodeResponse,
                append(
                        options,
                        httptransport.ServerBefore(opentracing.HTTPToContext(otTracer, "GetPendingCSRs", logger)),
                        httptransport.ServerBefore(HTTPToContext(logger)),
                )...,
        ))
        r.Methods("GET").Path("/v1/{id}").Handler(httptransport.NewServer(
                e.GetDMSbyIDEndpoint,
                decodeGetDMSbyIDRequest,
                encodeResponse,
                append(
                        options,
                        httptransport.ServerBefore(opentracing.HTTPToContext(otTracer, "GetDMSbyID", logger)),
                        httptransport.ServerBefore(HTTPToContext(logger)),
                )...,
        ))
        r.Methods("PUT").Path("/v1/{id}").Handler(httptransport.NewServer(
                e.PutChangeDMSStatusEndpoint,
                decodeputChangeDmsStatusRequest,
                encodeResponse,
                append(
                        options,
                        httptransport.ServerBefore(opentracing.HTTPToContext(otTracer, "PutChangeCSRStatus", logger)),
                        httptransport.ServerBefore(HTTPToContext(logger)),
                )...,
        ))

        r.Methods("DELETE").Path("/v1/{id}").Handler(httptransport.NewServer(
                e.DeleteDMSEndpoint,
                decodeDeleteCSRRequest,
                encodeResponse,
                append(
                        options,
                        httptransport.ServerBefore(opentracing.HTTPToContext(otTracer, "DeleteCSR", logger)),
                        httptransport.ServerBefore(HTTPToContext(logger)),
                )...,
        ))

        return r
}</span>

type PostDmsResponse struct {
        Dms dto.DMS `json:"dms,omitempty"`
        Err error   `json:"err,omitempty"`
}
type PostDmsCreationFormResponse struct {
        Dms     dto.DMS `json:"dms,omitempty"`
        PrivKey string  `json:"priv_key,omitempty"`
        Err     error   `json:"err,omitempty"`
}

type GetCRTResponse struct {
        Data *x509.Certificate
        Err  error
}

func decodeHealthRequest(ctx context.Context, r *http.Request) (request interface{}, err error) <span class="cov8" title="1">{
        var req endpoint.HealthRequest
        return req, nil
}</span>

func decodeGetDMSsRequest(ctx context.Context, r *http.Request) (request interface{}, err error) <span class="cov8" title="1">{
        var req endpoint.GetDmsRequest
        return req, nil
}</span>
func decodeGetDMSbyIDRequest(ctx context.Context, r *http.Request) (request interface{}, err error) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, _ := vars["id"]
        return endpoint.GetDmsIDRequest{ID: id}, nil
}</span>
func decodePostCreateDMSFormRequest(ctx context.Context, r *http.Request) (request interface{}, err error) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        name, _ := vars["name"]
        var dmsForm dto.PostDmsCreationFormRequest
        err = json.NewDecoder(r.Body).Decode((&amp;dmsForm))
        if err != nil </span><span class="cov8" title="1">{
                return nil, InvalidJsonFormat()
        }</span>
        <span class="cov8" title="1">dmsForm.DmsName = name
        return dmsForm, nil</span>
}

func decodePostCSRRequest(ctx context.Context, r *http.Request) (request interface{}, err error) <span class="cov8" title="1">{
        vars := mux.Vars(r)

        var csrRequest endpoint.PostDirectCsr
        err = json.NewDecoder(r.Body).Decode((&amp;csrRequest))
        if err != nil </span><span class="cov8" title="1">{
                return nil, InvalidJsonFormat()
        }</span>
        <span class="cov8" title="1">name, _ := vars["name"]

        req := dto.PostCSRRequest{
                Csr:     csrRequest.CsrBase64Encoded,
                DmsName: name,
        }
        return req, nil</span>
}

func decodeputChangeDmsStatusRequest(ctx context.Context, r *http.Request) (request interface{}, err error) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, _ := vars["id"]
        var Request dto.PutChangeDmsStatusRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;Request); err != nil </span><span class="cov8" title="1">{
                return nil, InvalidJsonFormat()
        }</span>
        <span class="cov8" title="1">if Request.Status == "" </span><span class="cov8" title="1">{
                return nil, ErrMissingDMSStatus()
        }</span>

        <span class="cov8" title="1">Request.ID = id
        return Request, nil</span>

}

func decodeDeleteCSRRequest(ctx context.Context, r *http.Request) (request interface{}, err error) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, _ := vars["id"]
        return endpoint.DeleteCSRRequest{ID: id}, nil
}</span>

func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error <span class="cov8" title="1">{
        if e, ok := response.(errorer); ok &amp;&amp; e.error() != nil </span><span class="cov0" title="0">{
                encodeError(ctx, e.error(), w)
                return nil
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json; charset=utf-8")
        return json.NewEncoder(w).Encode(response)</span>
}

func encodeError(_ context.Context, err error, w http.ResponseWriter) <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                panic("encodeError with nil error")</span>
        }
        <span class="cov8" title="1">http.Error(w, err.Error(), codeFrom(err))</span>
}

func codeFrom(err error) int <span class="cov8" title="1">{
        switch e := err.(type) </span>{
        case *dmsErrors.ValidationError:<span class="cov8" title="1">
                return http.StatusBadRequest</span>
        case *dmsErrors.DuplicateResourceError:<span class="cov8" title="1">
                return http.StatusConflict</span>
        case *dmsErrors.ResourceNotFoundError:<span class="cov8" title="1">
                return http.StatusNotFound</span>
        case *dmsErrors.GenericError:<span class="cov8" title="1">
                return e.StatusCode</span>
        default:<span class="cov0" title="0">
                return http.StatusInternalServerError</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import "github.com/kelseyhightower/envconfig"

type Config struct {
        Port     string `required:"true" split_words:"true"`
        Protocol string `required:"true" split_words:"true"`

        PostgresUser     string `required:"true" split_words:"true"`
        PostgresDB       string `required:"true" split_words:"true"`
        PostgresPassword string `required:"true" split_words:"true"`
        //PostgresDevicesDB string `required:"true" split_words:"true"`
        PostgresHostname string `required:"true" split_words:"true"`
        PostgresPort     string `required:"true" split_words:"true"`

        MutualTLSEnabled  bool   `split_words:"true"`
        MutualTLSClientCA string `split_words:"true"`

        LamassuCACertFile string `split_words:"true"`
        LamassuCAAddress  string `split_words:"true"`

        DebugMode string `required:"true" split_words:"true"`

        CertFile string `split_words:"true"`
        KeyFile  string `split_words:"true"`

        OpenapiEnableSecuritySchema     bool   `required:"true" split_words:"true"`
        OpenapiSecurityOidcWellKnownUrl string `split_words:"true"`
}

func NewConfig(prefix string) (error, Config) <span class="cov0" title="0">{
        var cfg Config
        err := envconfig.Process(prefix, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err, Config{}
        }</span>
        <span class="cov0" title="0">return nil, cfg</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package crypto

import (
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "io/ioutil"
)

const (
        CSRPEMBlockType  = "CERTIFICATE REQUEST"
        PublicKeyHeader  = "-----BEGIN PUBLIC KEY-----"
        PublicKeyFooter  = "-----END PUBLIC KEY-----"
        CertPEMBlockType = "CERTIFICATE"
        KeyPEMBlockType  = "RSA PRIVATE KEY"
)

func ParseKeycloakPublicKey(data []byte) (*rsa.PublicKey, error) <span class="cov8" title="1">{
        pubPem, _ := pem.Decode(data)
        parsedKey, err := x509.ParsePKIXPublicKey(pubPem.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Unable to parse public key")
        }</span>
        <span class="cov8" title="1">pubKey := parsedKey.(*rsa.PublicKey)
        return pubKey, nil</span>
}

func ParseNewCSR(data []byte) (*x509.CertificateRequest, error) <span class="cov8" title="1">{
        pemBlock, _ := pem.Decode(data)
        err := CheckPEMBlock(pemBlock, CSRPEMBlockType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">certReq, err := x509.ParseCertificateRequest(pemBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return certReq, nil</span>
}

func CheckPEMBlock(pemBlock *pem.Block, blockType string) error <span class="cov8" title="1">{
        if pemBlock == nil </span><span class="cov0" title="0">{
                return errors.New("cannot find the next PEM formatted block")
        }</span>
        <span class="cov8" title="1">if pemBlock.Type != blockType || len(pemBlock.Headers) != 0 </span><span class="cov0" title="0">{
                return errors.New("unmatched type of headers")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func CreateCAPool(CAPath string) (*x509.CertPool, error) <span class="cov8" title="1">{
        caCert, err := ioutil.ReadFile(CAPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">caCertPool := x509.NewCertPool()
        caCertPool.AppendCertsFromPEM(caCert)
        return caCertPool, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package docs

import (
        "github.com/getkin/kin-openapi/openapi3"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/config"
)

func NewOpenAPI3(config config.Config) openapi3.T <span class="cov0" title="0">{

        arrayOf := func(items *openapi3.SchemaRef) *openapi3.SchemaRef </span><span class="cov0" title="0">{
                return &amp;openapi3.SchemaRef{Value: &amp;openapi3.Schema{Type: "array", Items: items}}
        }</span>

        <span class="cov0" title="0">openapiSpec := openapi3.T{
                OpenAPI: "3.0.0",
                Info: &amp;openapi3.Info{
                        Title:       "Lamassu DMS Enroller API",
                        Description: "REST API used for interacting with Lamassu DMS Enroller",
                        Version:     "0.0.0",
                        License: &amp;openapi3.License{
                                Name: "MPL v2.0",
                                URL:  "https://github.com/lamassuiot/lamassu-compose/blob/main/LICENSE",
                        },
                        Contact: &amp;openapi3.Contact{
                                URL: "https://github.com/lamassuiot",
                        },
                },
                Servers: openapi3.Servers{
                        &amp;openapi3.Server{
                                Description: "Current Server",
                                URL:         "/",
                        },
                },
        }

        if config.OpenapiEnableSecuritySchema </span><span class="cov0" title="0">{
                openapiSpec.Security = *openapi3.NewSecurityRequirements().With(openapi3.NewSecurityRequirement().Authenticate("Keycloak"))
                oidc := openapi3.SecuritySchemeRef{
                        Value: openapi3.NewOIDCSecurityScheme(config.OpenapiSecurityOidcWellKnownUrl),
                }
                openapiSpec.Components.SecuritySchemes = openapi3.SecuritySchemes{
                        "Keycloak": &amp;oidc,
                }
        }</span>

        <span class="cov0" title="0">openapiSpec.Components.Schemas = openapi3.Schemas{
                "DMS": openapi3.NewSchemaRef("",
                        openapi3.NewObjectSchema().
                                WithProperty("id", openapi3.NewIntegerSchema()).
                                WithProperty("name", openapi3.NewStringSchema()).
                                WithProperty("serial_number", openapi3.NewStringSchema()).
                                WithPropertyRef("subject", &amp;openapi3.SchemaRef{
                                        Ref: "#/components/schemas/Subject",
                                }).
                                WithPropertyRef("key_metadata", &amp;openapi3.SchemaRef{
                                        Ref: "#/components/schemas/KeyMetadata",
                                }).
                                WithProperty("status", openapi3.NewStringSchema()).
                                WithPropertyRef("authorized_cas", arrayOf(&amp;openapi3.SchemaRef{
                                        Ref: "#/components/schemas/CAList",
                                })).
                                WithProperty("csr", openapi3.NewStringSchema()).
                                WithProperty("crt", openapi3.NewStringSchema()).
                                WithProperty("creation_timestamp", openapi3.NewStringSchema()).
                                WithProperty("modification_timestamp", openapi3.NewStringSchema()).
                                WithProperty("enrolled_devices", openapi3.NewIntegerSchema()),
                ),
                "Subject": openapi3.NewSchemaRef("",
                        openapi3.NewObjectSchema().
                                WithProperty("common_name", openapi3.NewStringSchema()).
                                WithProperty("organization", openapi3.NewStringSchema()).
                                WithProperty("organization_unit", openapi3.NewStringSchema()).
                                WithProperty("country", openapi3.NewStringSchema()).
                                WithProperty("state", openapi3.NewStringSchema()).
                                WithProperty("locality", openapi3.NewStringSchema()),
                ),
                "CAList": openapi3.NewSchemaRef("",
                        openapi3.NewStringSchema(),
                ),
                "KeyMetadata": openapi3.NewSchemaRef("",
                        openapi3.NewObjectSchema().
                                WithProperty("type", openapi3.NewStringSchema()).
                                WithProperty("bits", openapi3.NewIntegerSchema()),
                ),
        }

        openapiSpec.Components.RequestBodies = openapi3.RequestBodies{
                "postDMSRequest": &amp;openapi3.RequestBodyRef{
                        Value: openapi3.NewRequestBody().
                                WithDescription("Request used for creating a new DMS ").
                                WithRequired(true).
                                WithJSONSchema(openapi3.NewSchema().
                                        WithProperty("csr", openapi3.NewStringSchema()).
                                        WithProperty("name", openapi3.NewStringSchema()),
                                ),
                },
                "postDMSFormRequest": &amp;openapi3.RequestBodyRef{
                        Value: openapi3.NewRequestBody().
                                WithDescription("Request used for creating a new DMS Form").
                                WithRequired(true).
                                WithJSONSchema(openapi3.NewSchema().
                                        WithProperty("name", openapi3.NewStringSchema()).
                                        WithPropertyRef("subject", &amp;openapi3.SchemaRef{
                                                Ref: "#/components/schemas/Subject",
                                        }).
                                        WithPropertyRef("key_metadata", &amp;openapi3.SchemaRef{
                                                Ref: "#/components/schemas/KeyMetadata",
                                        }),
                                ),
                },
                "getPendingCSRRequest": &amp;openapi3.RequestBodyRef{
                        Value: openapi3.NewRequestBody().
                                WithDescription("Request used for creating a new CSR Form").
                                WithRequired(true).
                                WithContent(openapi3.NewContentWithJSONSchema(openapi3.NewSchema().
                                        WithProperty("ID", openapi3.NewIntegerSchema()))),
                },
                "PutChangeDMSStatus": &amp;openapi3.RequestBodyRef{
                        Value: openapi3.NewRequestBody().
                                WithDescription("Change DMS status ").
                                WithRequired(true).
                                WithJSONSchema(openapi3.NewSchema().
                                        WithProperty("status", openapi3.NewStringSchema()).
                                        WithPropertyRef("authorized_cas", arrayOf(&amp;openapi3.SchemaRef{
                                                Ref: "#/components/schemas/CAList",
                                        }))),
                },
        }

        openapiSpec.Components.Responses = openapi3.Responses{
                "ErrorResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response when errors happen.").
                                WithContent(openapi3.NewContentWithJSONSchema(openapi3.NewSchema().
                                        WithProperty("error", openapi3.NewStringSchema()))),
                },
                "HealthResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after healthchecking.").
                                WithContent(openapi3.NewContentWithJSONSchema(openapi3.NewSchema().
                                        WithProperty("healthy", openapi3.NewBoolSchema())),
                                ),
                },
                "PostDMSResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after creating a DMS.").
                                WithContent(openapi3.NewContentWithJSONSchemaRef(&amp;openapi3.SchemaRef{
                                        Ref: "#/components/schemas/DMS",
                                })),
                },
                "PostDMSFormResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after creating a DMS.").
                                WithContent(openapi3.NewContentWithJSONSchema(openapi3.NewSchema().
                                        WithPropertyRef("dms", &amp;openapi3.SchemaRef{
                                                Ref: "#/components/schemas/DMS",
                                        }).
                                        WithProperty("priv_key", openapi3.NewStringSchema())),
                                ),
                },
                "GetPendingDMSsResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after getting pending CSRs.").
                                WithContent(openapi3.NewContentWithJSONSchema(openapi3.NewSchema().
                                        WithPropertyRef("DMSs", arrayOf(&amp;openapi3.SchemaRef{
                                                Ref: "#/components/schemas/DMS",
                                        }))),
                                ),
                },
                "GetDMSByIDResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after getting pending CSRs.").
                                WithContent(openapi3.NewContentWithJSONSchema(openapi3.NewSchema().
                                        WithPropertyRef("dms", &amp;openapi3.SchemaRef{
                                                Ref: "#/components/schemas/DMS",
                                        })),
                                ),
                },

                "GetPendingCSRDBResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after getting pending CSRDB.").
                                WithContent(openapi3.NewContentWithJSONSchemaRef(&amp;openapi3.SchemaRef{
                                        Ref: "#/components/schemas/DMS",
                                })),
                },
                //TODO
                "GetPendingCSRFileResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after getting CSR File.").
                                WithContent(openapi3.NewContentWithJSONSchema(openapi3.NewSchema())),
                },
                "PutChangeDMSStatusResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after changing DMS Status.").
                                WithContent(openapi3.NewContentWithJSONSchemaRef(&amp;openapi3.SchemaRef{
                                        Ref: "#/components/schemas/DMS",
                                })),
                },
                "DeleteDMSResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after deleting DMS.").
                                WithContent(openapi3.NewContentWithJSONSchema(openapi3.NewSchema())),
                },
                "GetCRTResponse": &amp;openapi3.ResponseRef{
                        Value: openapi3.NewResponse().
                                WithDescription("Response returned back after getting Certificate.").
                                WithContent(openapi3.NewContentWithJSONSchema(openapi3.NewSchema())),
                },
        }

        openapiSpec.Paths = openapi3.Paths{
                "/v1/health": &amp;openapi3.PathItem{
                        Get: &amp;openapi3.Operation{
                                OperationID: "Health",
                                Description: "Get health status",
                                Responses: openapi3.Responses{
                                        "200": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/HealthResponse",
                                        },
                                },
                        },
                },
                "/v1/{name}": &amp;openapi3.PathItem{
                        Post: &amp;openapi3.Operation{
                                OperationID: "PostDMS",
                                Description: "Post DMS",
                                Parameters: []*openapi3.ParameterRef{
                                        {
                                                Value: openapi3.NewPathParameter("name").
                                                        WithSchema(openapi3.NewStringSchema()),
                                        },
                                },
                                RequestBody: &amp;openapi3.RequestBodyRef{
                                        Ref: "#/components/requestBodies/postDMSRequest",
                                },
                                Responses: openapi3.Responses{
                                        "400": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "401": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "403": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "500": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "200": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/PostDMSResponse",
                                        },
                                },
                        },
                },
                "/v1/{name}/form": &amp;openapi3.PathItem{
                        Post: &amp;openapi3.Operation{
                                OperationID: "PostDMSForm",
                                Description: "Post DMS Form",
                                Parameters: []*openapi3.ParameterRef{
                                        {
                                                Value: openapi3.NewPathParameter("name").
                                                        WithSchema(openapi3.NewStringSchema()),
                                        },
                                },
                                RequestBody: &amp;openapi3.RequestBodyRef{
                                        Ref: "#/components/requestBodies/postDMSFormRequest",
                                },
                                Responses: openapi3.Responses{
                                        "400": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "401": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "403": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "500": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "200": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/PostDMSFormResponse",
                                        },
                                },
                        },
                },
                "/v1/": &amp;openapi3.PathItem{
                        Get: &amp;openapi3.Operation{
                                OperationID: "GetDMSs",
                                Description: "Get DMSs",
                                Responses: openapi3.Responses{
                                        "400": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "401": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "403": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "500": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "200": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/GetPendingDMSsResponse",
                                        },
                                },
                        },
                },

                "/v1/{id}": &amp;openapi3.PathItem{
                        Put: &amp;openapi3.Operation{
                                OperationID: "PutChangeDMSStatus",
                                Description: "Change DMS Status by id",
                                Parameters: []*openapi3.ParameterRef{
                                        {
                                                Value: openapi3.NewPathParameter("id").
                                                        WithSchema(openapi3.NewStringSchema()),
                                        },
                                },
                                RequestBody: &amp;openapi3.RequestBodyRef{
                                        Ref: "#/components/requestBodies/PutChangeDMSStatus",
                                },
                                Responses: openapi3.Responses{
                                        "400": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "401": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "403": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "500": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "200": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/PutChangeDMSStatusResponse",
                                        },
                                },
                        },
                        Get: &amp;openapi3.Operation{
                                OperationID: "GetDMSbyID",
                                Description: "Get DMS by ID",
                                Parameters: []*openapi3.ParameterRef{
                                        {
                                                Value: openapi3.NewPathParameter("id").
                                                        WithSchema(openapi3.NewStringSchema()),
                                        },
                                },
                                Responses: openapi3.Responses{
                                        "400": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "401": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "403": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "500": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "200": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/GetDMSByIDResponse",
                                        },
                                },
                        },
                        Delete: &amp;openapi3.Operation{
                                OperationID: "DeleteDMS",
                                Description: "Delete DMS by id",
                                Parameters: []*openapi3.ParameterRef{
                                        {
                                                Value: openapi3.NewPathParameter("id").
                                                        WithSchema(openapi3.NewStringSchema()),
                                        },
                                },
                                Responses: openapi3.Responses{
                                        "400": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "401": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "403": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "500": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "200": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/DeleteDMSResponse",
                                        },
                                },
                        },
                },
                "/v1/{id}/crt": &amp;openapi3.PathItem{
                        Get: &amp;openapi3.Operation{
                                OperationID: "GetCRT",
                                Description: "Get CRT by id",
                                Parameters: []*openapi3.ParameterRef{
                                        {
                                                Value: openapi3.NewPathParameter("id").
                                                        WithSchema(openapi3.NewStringSchema()),
                                        },
                                },
                                Responses: openapi3.Responses{
                                        "400": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "401": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "403": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "500": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/ErrorResponse",
                                        },
                                        "200": &amp;openapi3.ResponseRef{
                                                Ref: "#/components/responses/GetCRTResponse",
                                        },
                                },
                        },
                },
        }

        return openapiSpec</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mocks

import (
        "context"
        "database/sql"
        "os"
        "testing"

        "github.com/go-kit/log"
        "github.com/go-kit/log/level"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/common/dto"
        dmserrors "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/errors"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/models/dms"
)

var dmsDB dto.DMS
var authCAs []dms.AuthorizedCAs

type MockDB struct {
        *sql.DB
        logger log.Logger
}

func NewDB(t *testing.T) (*MockDB, error) <span class="cov8" title="1">{
        t.Helper()
        db, err := sql.Open("driverName", "dataSourceName")

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var logger log.Logger
        </span><span class="cov0" title="0">{
                logger = log.NewJSONLogger(os.Stdout)
                logger = log.With(logger, "ts", log.DefaultTimestampUTC)
                logger = level.NewFilter(logger, level.AllowInfo())
                logger = log.With(logger, "caller", log.DefaultCaller)
        }</span>

        <span class="cov0" title="0">return &amp;MockDB{db, logger}, nil</span>

}

func checkDBAlive(db *MockDB) error <span class="cov0" title="0">{
        sqlStatement := `
        SELECT WHERE 1=0`
        _, err := db.Query(sqlStatement)
        return err
}</span>

func (db *MockDB) Insert(ctx context.Context, d dto.DMS) (string, error) <span class="cov8" title="1">{
        if d.Id == dmsDB.Id </span><span class="cov0" title="0">{
                duplicationErr := &amp;dmserrors.DuplicateResourceError{
                        ResourceType: "Insert DMS",
                        ResourceId:   d.Id,
                }
                return "", duplicationErr
        }</span> else<span class="cov8" title="1"> {
                dmsDB = d
                return dmsDB.Id, nil
        }</span>

}
func (db *MockDB) SelectAllAuthorizedCAs(ctx context.Context) ([]dms.AuthorizedCAs, error) <span class="cov0" title="0">{
        if len(authCAs) == 0 </span><span class="cov0" title="0">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "DMS",
                        ResourceId:   "Database is empty",
                }
                return []dms.AuthorizedCAs{}, notFoundErr
        }</span> else<span class="cov0" title="0"> {
                return authCAs, nil
        }</span>
}

func (db *MockDB) SelectBySerialNumber(ctx context.Context, SerialNumber string) (string, error) <span class="cov0" title="0">{
        if SerialNumber != dmsDB.SerialNumber </span><span class="cov0" title="0">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "DMS",
                        ResourceId:   SerialNumber,
                }
                return "", notFoundErr
        }</span> else<span class="cov0" title="0"> {
                return dmsDB.Id, nil
        }</span>
}
func (db *MockDB) SelectAll(ctx context.Context) ([]dto.DMS, error) <span class="cov8" title="1">{
        dmsArray := []dto.DMS{}
        if dmsDB.Id == "" </span><span class="cov8" title="1">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "Select All DMS",
                        ResourceId:   "Database is empty",
                }
                return []dto.DMS{}, notFoundErr
        }</span> else<span class="cov8" title="1"> {
                dmsArray = append(dmsArray, dmsDB)
                return dmsArray, nil
        }</span>

}

func (db *MockDB) SelectByID(ctx context.Context, id string) (dto.DMS, error) <span class="cov8" title="1">{
        if id != dmsDB.Id </span><span class="cov8" title="1">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "Select DMS by ID",
                        ResourceId:   id,
                }
                return dto.DMS{}, notFoundErr
        }</span> else<span class="cov8" title="1"> {
                return dmsDB, nil
        }</span>
}

func (db *MockDB) UpdateByID(ctx context.Context, id string, status string, serialNumber string, encodedCsr string) (dto.DMS, error) <span class="cov8" title="1">{

        if id != dmsDB.Id </span><span class="cov0" title="0">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "Update DMS",
                        ResourceId:   id,
                }
                return dto.DMS{}, notFoundErr
        }</span> else<span class="cov8" title="1"> {
                dmsDB.Status = status
                dmsDB.SerialNumber = serialNumber
                dmsDB.CsrBase64 = encodedCsr
                return dmsDB, nil
        }</span>

}

func (db *MockDB) Delete(ctx context.Context, id string) error <span class="cov8" title="1">{
        if id != dmsDB.Id </span><span class="cov0" title="0">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "Delete DMS",
                        ResourceId:   id,
                }
                return notFoundErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

func (db *MockDB) InsertAuthorizedCAs(ctx context.Context, dmsid string, CAs []string) error <span class="cov8" title="1">{
        if len(CAs) != 1 </span><span class="cov8" title="1">{
                for i := 0; i &lt; len(CAs); i++ </span><span class="cov8" title="1">{
                        if CAs[i] == CAs[i+1] </span><span class="cov8" title="1">{
                                duplicationErr := &amp;dmserrors.DuplicateResourceError{
                                        ResourceType: "Insert AuthCAs DMS",
                                        ResourceId:   dmsid,
                                }
                                return duplicationErr
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(authCAs) == 0 </span><span class="cov8" title="1">{
                for i := 0; i &lt; len(CAs); i++ </span><span class="cov8" title="1">{
                        cas := dms.AuthorizedCAs{
                                DmsId:  dmsid,
                                CaName: CAs[i],
                        }
                        authCAs = append(authCAs, cas)
                }</span>
        } else<span class="cov8" title="1"> {
                var lenAuthCas = len(authCAs)
                for i := 0; i &lt; len(CAs); i++ </span><span class="cov8" title="1">{
                        for j := 0; j &lt; lenAuthCas; j++ </span><span class="cov8" title="1">{
                                if authCAs[j].DmsId == dmsid &amp;&amp; authCAs[j].CaName == CAs[i] </span><span class="cov0" title="0">{
                                        duplicationErr := &amp;dmserrors.DuplicateResourceError{
                                                ResourceType: "Insert AuthCAs DMS",
                                                ResourceId:   dmsid,
                                        }
                                        return duplicationErr
                                }</span> else<span class="cov8" title="1"> {
                                        cas := dms.AuthorizedCAs{
                                                DmsId:  dmsid,
                                                CaName: CAs[i],
                                        }
                                        authCAs = append(authCAs, cas)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (db *MockDB) DeleteAuthorizedCAs(ctx context.Context, dmsid string) error <span class="cov8" title="1">{
        var count = 0
        for i := 0; i &lt; len(authCAs); i++ </span><span class="cov8" title="1">{
                if authCAs[i].DmsId != dmsid </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">if count == len(authCAs) </span><span class="cov0" title="0">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "DMS",
                        ResourceId:   dmsid,
                }
                return notFoundErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>

}

func (db *MockDB) SelectByDMSIDAuthorizedCAs(ctx context.Context, dmsid string) ([]dms.AuthorizedCAs, error) <span class="cov8" title="1">{
        var count = 0
        var cas []dms.AuthorizedCAs
        for i := 0; i &lt; len(authCAs); i++ </span><span class="cov8" title="1">{
                if authCAs[i].DmsId != dmsid </span><span class="cov8" title="1">{
                        count++
                }</span> else<span class="cov8" title="1"> {
                        casauth := dms.AuthorizedCAs{
                                DmsId:  dmsid,
                                CaName: authCAs[i].CaName,
                        }
                        cas = append(cas, casauth)
                }</span>
        }
        <span class="cov8" title="1">if count == len(authCAs) </span><span class="cov0" title="0">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "        Select DMS Auth CAs",
                        ResourceId: dmsid,
                }
                return []dms.AuthorizedCAs{}, notFoundErr
        }</span> else<span class="cov8" title="1"> {
                return cas, nil
        }</span>
}

func testDMS(status string) dto.DMS <span class="cov0" title="0">{

        key := dto.PrivateKeyMetadataWithStregth{
                KeyType:     "RSA",
                KeyBits:     3072,
                KeyStrength: "low",
        }
        device := dto.DMS{
                Id:               "1",
                Name:             "test",
                SerialNumber:     "23-33-5b-19-c8-ed-8b-2a-92-5c-7b-57-fc-47-45-e7-12-03-91-23",
                KeyMetadata:      key,
                Status:           status,
                CsrBase64:        "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNURENDQWZPZ0F3SUJBZ0lVZnRXcTVObnpXZHUrSHk2S1RTMmpWazcybzRjd0NnWUlLb1pJemowRUF3SXcKY3pFTE1Ba0dBMVVFQmhNQ1JWTXhFVEFQQmdOVkJBZ1RDRWRwY0hWNmEyOWhNUkV3RHdZRFZRUUhFd2hCY25KaApjMkYwWlRFaE1BNEdBMVVFQ2hNSFV5NGdRMjl2Y0RBUEJnTlZCQW9UQ0V4TFV5Qk9aWGgwTVJzd0dRWURWUVFECkV4Sk1TMU1nVG1WNGRDQlNiMjkwSUVOQklETXdJQmNOTWpJd01USXdNVEV3TWpJMVdoZ1BNakExTWpBeE1UTXgKTVRBeU5UVmFNSE14Q3pBSkJnTlZCQVlUQWtWVE1SRXdEd1lEVlFRSUV3aEhhWEIxZW10dllURVJNQThHQTFVRQpCeE1JUVhKeVlYTmhkR1V4SVRBT0JnTlZCQW9UQjFNdUlFTnZiM0F3RHdZRFZRUUtFd2hNUzFNZ1RtVjRkREViCk1Ca0dBMVVFQXhNU1RFdFRJRTVsZUhRZ1VtOXZkQ0JEUVNBek1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMEQKQVFjRFFnQUU1aTFxZnlZU2xLaWt3SDhGZkhvQWxVWE44RlE3aE1OMERaTk8vVzdiSE44NVFpZ09ZeVQ1bWNYMgpXbDJtSTVEL0xQT1BKd0l4N1ZZcmxZU1BMTm5ndjZOak1HRXdEZ1lEVlIwUEFRSC9CQVFEQWdFR01BOEdBMVVkCkV3RUIvd1FGTUFNQkFmOHdIUVlEVlIwT0JCWUVGUGRURSs3a0k2MXFXSHFtUktZai9OaElIS01lTUI4R0ExVWQKSXdRWU1CYUFGUGRURSs3a0k2MXFXSHFtUktZai9OaElIS01lTUFvR0NDcUdTTTQ5QkFNQ0EwY0FNRVFDSUI2QQptZStjRzQ0MjBpNE5QZ1ZwWVRHN3hFN2lvbG0xOXhqRC9PcS9TeWt0QWlBaWRBK2JTanpvVHZxckRieDBqaHBiCmJpTnFycHZJY255TEY1MXQ5cHdBL1E9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0t",
                CerificateBase64: "LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFNWkxcWZ5WVNsS2lrd0g4RmZIb0FsVVhOOEZRNwpoTU4wRFpOTy9XN2JITjg1UWlnT1l5VDVtY1gyV2wybUk1RC9MUE9QSndJeDdWWXJsWVNQTE5uZ3Z3PT0KLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg",
        }

        return device
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package mocks

import (
        "context"
        "crypto/rand"
        "crypto/x509"
        "crypto/x509/pkix"
        "errors"
        "math/big"
        "strings"
        "time"

        "github.com/go-kit/kit/log"
        "github.com/jakehl/goid"
        lamassuca "github.com/lamassuiot/lamassuiot/pkg/ca/client"
        "github.com/lamassuiot/lamassuiot/pkg/ca/common/dto"
        caDTO "github.com/lamassuiot/lamassuiot/pkg/ca/common/dto"
        dmserrors "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/errors"
        "github.com/lamassuiot/lamassuiot/pkg/utils"
        clientUtils "github.com/lamassuiot/lamassuiot/pkg/utils/client"
)

var cert *x509.Certificate
var ca dto.Cert

type LamassuCaClientConfig struct {
        client clientUtils.BaseClient
        logger log.Logger
}

func NewLamassuCaClientMock(logger log.Logger) (lamassuca.LamassuCaClient, error) <span class="cov8" title="1">{

        return &amp;LamassuCaClientConfig{
                client: nil,
                logger: logger,
        }, nil
}</span>

func (c *LamassuCaClientConfig) GetCAs(ctx context.Context, caType caDTO.CAType) ([]caDTO.Cert, error) <span class="cov0" title="0">{

        var CAs []caDTO.Cert
        newCA := testCert()
        CAs = append(CAs, newCA)
        failDB := ctx.Value("DBShouldFail").(bool)

        if failDB </span><span class="cov0" title="0">{

                return CAs, errors.New("Error in client request")
        }</span> else<span class="cov0" title="0"> {
                return CAs, nil
        }</span>
}

func (c *LamassuCaClientConfig) CreateCA(ctx context.Context, caType dto.CAType, caName string, privateKeyMetadata caDTO.PrivateKeyMetadata, subject caDTO.Subject, caTTL time.Duration, enrollerTTL time.Duration) (dto.Cert, error) <span class="cov0" title="0">{
        certContent := caDTO.CertContent{
                CerificateBase64: "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUZtVENDQTRHZ0F3SUJBZ0lVSG1yc3dnVms3MlZtZjF1dWU3UVZKUm5vTEljd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1hERUxNQWtHQTFVRUJoTUNSVk14RVRBUEJnTlZCQWdNQ0VkcGNIVjZhMjloTVJFd0R3WURWUVFIREFoQgpjbkpoYzJGMFpURU1NQW9HQTFVRUNnd0RTVXRNTVF3d0NnWURWUVFMREFOYVVFUXhDekFKQmdOVkJBTU1Ba05CCk1CNFhEVEl5TURJeE5qRXhORGd4TTFvWERUSXpNREl4TmpFeE5EZ3hNMW93WERFTE1Ba0dBMVVFQmhNQ1JWTXgKRVRBUEJnTlZCQWdNQ0VkcGNIVjZhMjloTVJFd0R3WURWUVFIREFoQmNuSmhjMkYwWlRFTU1Bb0dBMVVFQ2d3RApTVXRNTVF3d0NnWURWUVFMREFOYVVFUXhDekFKQmdOVkJBTU1Ba05CTUlJQ0lqQU5CZ2txaGtpRzl3MEJBUUVGCkFBT0NBZzhBTUlJQ0NnS0NBZ0VBbWhONFVIdnRUcTVyelhXN01ibzltNTRicXRoeVlvdlNOODZmWkxFN0FqS3gKSVVpU0JCSVFUZkwyWVdqdXB5NFFBR0ZhU085WXk1Q1MvOVV1MWZTYTkrcFJ1QmVBZ1hVSTVzcXhlZEN6WEtScgpPT0R3L1I0dGkydVJUUEpzZWJ2K3l3MUswd3Z0R00yTXlLYTMyNFRMZnQ5UE05Nlc5VWsrOHlYc1dYQlo2Z1g4CnQ5cHJydkFrWkNRUlhDbTZ5amg1RWRIb2QxRy82TU95Y0RMVVN6RGhwcVpHaFVjTnl0RUxiOHA2ZGllNTRPOVoKWlB3TDl2QmpWemNROHo0WDBiWi9RbFJUcWhIQXJxUUxHaG02TTlTdkxUM0hLU1NoL1BpU2JhODk1V3h0OGJNMAo0Um9zYy96aDN3eVVSZVV1SFdQZm9uQWFGWjAxNFJCQ1Bud3Zub0dVeW8xRDIreWxncnhqRkJOQndzbm0rU1NPClVnN09JU05XaDRHK1RYa2JrK1RSajEvV0RGV2lDcC8wdmlacS95ZE02WWJNRHp2eWl0NWhsUnBxNXpYTzVFZi8KYlZmbVk0RXd2Ukx2RkVkNE1SelI2SWQrRjB4UWd1MFFWWmYwZHdGVU12V2Q2dUZOa3NSbDl2Z3hiNmZyQVFHbgp1VkVvTnVBN1VUZ1NCOVA5aXFKY2tBMFhacjQyaEcwYUw2b0FPdUxYZHU0azFkcm5ZMzRwdFhPRGNuRjBBMWl2ClV6SFhCNm9UNlRhSk5hQUlRVm5ETWJhWkRjcldGdmpVam9TNU45L2crQlRmVW42dWV1U3MzaTk5cHlZWTJ2Z24KVDFyV2xHUng2azQ5V2tBajQ3OG1wdFd6K01VeFJJVkl5bFlCNmxlMGUvMHlLR3FuZWd1R3Z4N0JjanhqTVhFQwpBd0VBQWFOVE1GRXdIUVlEVlIwT0JCWUVGQjNTNkE5NTQzT21oaTNhVFpYQVM2VjRiRjlKTUI4R0ExVWRJd1FZCk1CYUFGQjNTNkE5NTQzT21oaTNhVFpYQVM2VjRiRjlKTUE4R0ExVWRFd0VCL3dRRk1BTUJBZjh3RFFZSktvWkkKaHZjTkFRRUxCUUFEZ2dJQkFGdHFRVEZUNGozcmUwanJrSjZBUDBrMk0raWhYall0MVk1c0ZvbWNaY2pFaWVKcApETDJDam04WEdnRWNHdkp6K01oSDY1T2hITHZIRU9tbjkvckcwWStsTzhhYmhTQ1pIZWVqYWRLNEFSSlhHSlQ3CkZPRVBDNjgrRVl5SG9wai8xUmRCSXhjMkN4WFFwOC9IYzA2bDVOUTBZS3ZmYW5vM0ZGSFZEN09YT2tQSTVNSWcKN1JDOWVNL2Z4NlVyaHNhVTNERzlMcVBxNEMzcFFmRnEvTHBublBnYjRsbmlRQVZ0ZXRoWWhNSHFDUHdMMVJvQQoxTmdUZmJrWjBQaDl6N2cySUF4MW9SOXo5dWk0WWRWOVpycjhQTDBPaG4zM3BPbFJrZDNUcWJiY3FWcHBEL282CmFYZlJVU2taQWhoMXg4MlpzN2U2b2x4ekNTc3p0KzhUOTRtU0I5OWRoSDJiVnh4RWpPb3cvSklwNnlMT2JnUGcKdjZaRzROMEVaU2JlSGRzZ2ovbTd6RHg5Tlk2WGkrTUpidGlZdkRrdWpnRjdPanpVZkF3TUFaRzdOR0YraDNMWgpKb2EzQUg0ZDQ2UjFRVXRLQTdmUEpVb0pTb0xTVDZSOW9PR3dacUEzK1p6dDd4VFNoZkc2VDY0OWYxZ2c3OFhoCmRtM3hRYjZERUQvYk1iY3hGZUlvUW0yTklBS3VyUkMrV0hCMXFpZWlEdnZNd21IdjZGNHlvVWpNWEsyQVdWZysKWEJmb01KejZTYWZaOFlBWEhyVWdCdG8rVi95WTNaZzErOWdva0ZIOUkySHRFK1dOeUZjdUc3NEFoWlNMUHdiVgpwaE1FQUhHeTZVZWZaWlVpRTJ4SHFZRElDbVlWUlBUNGdrWlNqTXFKRDZ6ZExWTUNLcG81RnFXbEdvZEQKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ==",
                PublicKeyBase64:  "LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFNWkxcWZ5WVNsS2lrd0g4RmZIb0FsVVhOOEZRNwpoTU4wRFpOTy9XN2JITjg1UWlnT1l5VDVtY1gyV2wybUk1RC9MUE9QSndJeDdWWXJsWVNQTE5uZ3Z3PT0KLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==",
        }
        key_metadata := caDTO.PrivateKeyMetadataWithStregth{
                KeyType:     privateKeyMetadata.KeyType,
                KeyBits:     privateKeyMetadata.KeyBits,
                KeyStrength: "high",
        }
        ca = caDTO.Cert{
                Status:       "issued",
                SerialNumber: goid.NewV4UUID().String(),
                Name:         caName,
                KeyMetadata:  key_metadata,
                Subject:      subject,
                CertContent:  certContent,
                CaTTL:        int(caTTL),
                EnrollerTTL:  int(enrollerTTL),
                ValidFrom:    "2021-02-16 16:42:31.3773933 +0000 UTC",
                ValidTo:      "2022-01-01 16:42:31.3773933 +0000 UTC",
        }
        return dto.Cert{}, nil
}</span>

func (c *LamassuCaClientConfig) ImportCA(ctx context.Context, caType dto.CAType, caName string, certificate x509.Certificate, privateKey dto.PrivateKey, enrollerTTL time.Duration) (dto.Cert, error) <span class="cov0" title="0">{

        return dto.Cert{}, nil
}</span>

func (c *LamassuCaClientConfig) DeleteCA(ctx context.Context, caType dto.CAType, caName string) error <span class="cov0" title="0">{

        return nil
}</span>
func (c *LamassuCaClientConfig) SignCertificateRequest(ctx context.Context, caType caDTO.CAType, caName string, csr *x509.CertificateRequest, signVerbatim bool) (*x509.Certificate, *x509.Certificate, error) <span class="cov8" title="1">{

        serialnumber, _ := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 160))
        cert = &amp;x509.Certificate{
                SerialNumber: serialnumber,
                Subject: pkix.Name{
                        Organization:       CheckIfNull(csr.Subject.Organization),
                        Country:            CheckIfNull(csr.Subject.Country),
                        Province:           CheckIfNull(csr.Subject.Province),
                        Locality:           CheckIfNull(csr.Subject.Locality),
                        OrganizationalUnit: CheckIfNull(csr.Subject.OrganizationalUnit),
                        CommonName:         goid.NewV4UUID().String(),
                },
                NotBefore:             time.Now(),
                NotAfter:              time.Now().AddDate(10, 0, 0),
                IsCA:                  false,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
                KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
                BasicConstraintsValid: true,
                Issuer: pkix.Name{
                        CommonName: caName,
                },
        }
        return cert, nil, nil

}</span>

func (c *LamassuCaClientConfig) RevokeCert(ctx context.Context, caType caDTO.CAType, caName string, serialNumberToRevoke string) error <span class="cov8" title="1">{
        if caName != ca.Name &amp;&amp; utils.InsertNth(utils.ToHexInt(cert.SerialNumber), 2) != serialNumberToRevoke </span><span class="cov0" title="0">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "Revoke Cert",
                        ResourceId:   serialNumberToRevoke,
                }
                return notFoundErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

func (c *LamassuCaClientConfig) GetIssuedCerts(ctx context.Context, caType caDTO.CAType, caName string, queryParameters string) (caDTO.IssuedCertsResponse, error) <span class="cov0" title="0">{

        return caDTO.IssuedCertsResponse{}, nil
}</span>

func (c *LamassuCaClientConfig) GetCert(ctx context.Context, caType caDTO.CAType, caName string, SerialNumber string) (caDTO.Cert, error) <span class="cov8" title="1">{

        if cert == nil || caName != ca.Name || utils.InsertNth(utils.ToHexInt(cert.SerialNumber), 2) != SerialNumber </span><span class="cov8" title="1">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "Revoke Cert",
                        ResourceId:   SerialNumber,
                }
                return caDTO.Cert{}, notFoundErr
        }</span> else<span class="cov0" title="0"> {
                return dto.Cert{
                        SerialNumber: utils.InsertNth(utils.ToHexInt(cert.SerialNumber), 2),
                        Status:       "issued",
                        Name:         caName,
                        Subject: dto.Subject{
                                C:  strings.Join(cert.Subject.Country, " "),
                                ST: strings.Join(cert.Subject.Province, " "),
                                L:  strings.Join(cert.Subject.Locality, " "),
                                O:  strings.Join(cert.Subject.Organization, " "),
                                OU: strings.Join(cert.Subject.OrganizationalUnit, " "),
                                CN: cert.Subject.CommonName,
                        },
                        ValidFrom: cert.NotBefore.String(),
                        ValidTo:   cert.NotAfter.String(),
                }, nil
        }</span>

}

func testCert() caDTO.Cert <span class="cov0" title="0">{

        serialNumber := "1E-6A-EC-C2-05-64-EF-65-66-7F-5B-AE-7B-B4-15-25-19-E8-2C-87"

        keyMetadata := caDTO.PrivateKeyMetadataWithStregth{
                KeyType:     "RSA",
                KeyBits:     4096,
                KeyStrength: "high",
        }

        subject := caDTO.Subject{
                CN: "CA",
                OU: "ZPD",
                O:  "IKL",
                L:  "Arrasate",
                ST: "Gipuzkoa",
                C:  "ES",
        }

        certContent := caDTO.CertContent{
                CerificateBase64: "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUZtVENDQTRHZ0F3SUJBZ0lVSG1yc3dnVms3MlZtZjF1dWU3UVZKUm5vTEljd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1hERUxNQWtHQTFVRUJoTUNSVk14RVRBUEJnTlZCQWdNQ0VkcGNIVjZhMjloTVJFd0R3WURWUVFIREFoQgpjbkpoYzJGMFpURU1NQW9HQTFVRUNnd0RTVXRNTVF3d0NnWURWUVFMREFOYVVFUXhDekFKQmdOVkJBTU1Ba05CCk1CNFhEVEl5TURJeE5qRXhORGd4TTFvWERUSXpNREl4TmpFeE5EZ3hNMW93WERFTE1Ba0dBMVVFQmhNQ1JWTXgKRVRBUEJnTlZCQWdNQ0VkcGNIVjZhMjloTVJFd0R3WURWUVFIREFoQmNuSmhjMkYwWlRFTU1Bb0dBMVVFQ2d3RApTVXRNTVF3d0NnWURWUVFMREFOYVVFUXhDekFKQmdOVkJBTU1Ba05CTUlJQ0lqQU5CZ2txaGtpRzl3MEJBUUVGCkFBT0NBZzhBTUlJQ0NnS0NBZ0VBbWhONFVIdnRUcTVyelhXN01ibzltNTRicXRoeVlvdlNOODZmWkxFN0FqS3gKSVVpU0JCSVFUZkwyWVdqdXB5NFFBR0ZhU085WXk1Q1MvOVV1MWZTYTkrcFJ1QmVBZ1hVSTVzcXhlZEN6WEtScgpPT0R3L1I0dGkydVJUUEpzZWJ2K3l3MUswd3Z0R00yTXlLYTMyNFRMZnQ5UE05Nlc5VWsrOHlYc1dYQlo2Z1g4CnQ5cHJydkFrWkNRUlhDbTZ5amg1RWRIb2QxRy82TU95Y0RMVVN6RGhwcVpHaFVjTnl0RUxiOHA2ZGllNTRPOVoKWlB3TDl2QmpWemNROHo0WDBiWi9RbFJUcWhIQXJxUUxHaG02TTlTdkxUM0hLU1NoL1BpU2JhODk1V3h0OGJNMAo0Um9zYy96aDN3eVVSZVV1SFdQZm9uQWFGWjAxNFJCQ1Bud3Zub0dVeW8xRDIreWxncnhqRkJOQndzbm0rU1NPClVnN09JU05XaDRHK1RYa2JrK1RSajEvV0RGV2lDcC8wdmlacS95ZE02WWJNRHp2eWl0NWhsUnBxNXpYTzVFZi8KYlZmbVk0RXd2Ukx2RkVkNE1SelI2SWQrRjB4UWd1MFFWWmYwZHdGVU12V2Q2dUZOa3NSbDl2Z3hiNmZyQVFHbgp1VkVvTnVBN1VUZ1NCOVA5aXFKY2tBMFhacjQyaEcwYUw2b0FPdUxYZHU0azFkcm5ZMzRwdFhPRGNuRjBBMWl2ClV6SFhCNm9UNlRhSk5hQUlRVm5ETWJhWkRjcldGdmpVam9TNU45L2crQlRmVW42dWV1U3MzaTk5cHlZWTJ2Z24KVDFyV2xHUng2azQ5V2tBajQ3OG1wdFd6K01VeFJJVkl5bFlCNmxlMGUvMHlLR3FuZWd1R3Z4N0JjanhqTVhFQwpBd0VBQWFOVE1GRXdIUVlEVlIwT0JCWUVGQjNTNkE5NTQzT21oaTNhVFpYQVM2VjRiRjlKTUI4R0ExVWRJd1FZCk1CYUFGQjNTNkE5NTQzT21oaTNhVFpYQVM2VjRiRjlKTUE4R0ExVWRFd0VCL3dRRk1BTUJBZjh3RFFZSktvWkkKaHZjTkFRRUxCUUFEZ2dJQkFGdHFRVEZUNGozcmUwanJrSjZBUDBrMk0raWhYall0MVk1c0ZvbWNaY2pFaWVKcApETDJDam04WEdnRWNHdkp6K01oSDY1T2hITHZIRU9tbjkvckcwWStsTzhhYmhTQ1pIZWVqYWRLNEFSSlhHSlQ3CkZPRVBDNjgrRVl5SG9wai8xUmRCSXhjMkN4WFFwOC9IYzA2bDVOUTBZS3ZmYW5vM0ZGSFZEN09YT2tQSTVNSWcKN1JDOWVNL2Z4NlVyaHNhVTNERzlMcVBxNEMzcFFmRnEvTHBublBnYjRsbmlRQVZ0ZXRoWWhNSHFDUHdMMVJvQQoxTmdUZmJrWjBQaDl6N2cySUF4MW9SOXo5dWk0WWRWOVpycjhQTDBPaG4zM3BPbFJrZDNUcWJiY3FWcHBEL282CmFYZlJVU2taQWhoMXg4MlpzN2U2b2x4ekNTc3p0KzhUOTRtU0I5OWRoSDJiVnh4RWpPb3cvSklwNnlMT2JnUGcKdjZaRzROMEVaU2JlSGRzZ2ovbTd6RHg5Tlk2WGkrTUpidGlZdkRrdWpnRjdPanpVZkF3TUFaRzdOR0YraDNMWgpKb2EzQUg0ZDQ2UjFRVXRLQTdmUEpVb0pTb0xTVDZSOW9PR3dacUEzK1p6dDd4VFNoZkc2VDY0OWYxZ2c3OFhoCmRtM3hRYjZERUQvYk1iY3hGZUlvUW0yTklBS3VyUkMrV0hCMXFpZWlEdnZNd21IdjZGNHlvVWpNWEsyQVdWZysKWEJmb01KejZTYWZaOFlBWEhyVWdCdG8rVi95WTNaZzErOWdva0ZIOUkySHRFK1dOeUZjdUc3NEFoWlNMUHdiVgpwaE1FQUhHeTZVZWZaWlVpRTJ4SHFZRElDbVlWUlBUNGdrWlNqTXFKRDZ6ZExWTUNLcG81RnFXbEdvZEQKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ==",
                PublicKeyBase64:  "LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFNWkxcWZ5WVNsS2lrd0g4RmZIb0FsVVhOOEZRNwpoTU4wRFpOTy9XN2JITjg1UWlnT1l5VDVtY1gyV2wybUk1RC9MUE9QSndJeDdWWXJsWVNQTE5uZ3Z3PT0KLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==",
        }

        cert := caDTO.Cert{
                Status:       "issued",
                SerialNumber: serialNumber,
                Name:         "CA",
                KeyMetadata:  keyMetadata,
                Subject:      subject,
                CertContent:  certContent,
                ValidFrom:    "2021-02-16 16:42:31.3773933 +0000 UTC",
                ValidTo:      "2022-01-01 16:42:31.3773933 +0000 UTC",
        }
        return cert
}</span>
func CheckIfNull(field []string) []string <span class="cov8" title="1">{
        var result []string
        result = append(result, "")
        if field != nil </span><span class="cov8" title="1">{
                result = append(result, field...)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package db

import (
        "context"
        "database/sql"
        "errors"
        "strconv"
        "time"

        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/common/dto"
        dmserrors "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/api/errors"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/models/dms"
        "github.com/lamassuiot/lamassuiot/pkg/dms-enroller/server/models/dms/store"
        "github.com/lamassuiot/lamassuiot/pkg/utils"
        "github.com/opentracing/opentracing-go"

        "github.com/go-kit/kit/log"
        "github.com/go-kit/kit/log/level"

        _ "github.com/lib/pq"
)

func NewDB(db *sql.DB, logger log.Logger) store.DB <span class="cov0" title="0">{
        return &amp;DB{db, logger}
}</span>

type DB struct {
        *sql.DB
        logger log.Logger
}

func checkDBAlive(db *sql.DB) error <span class="cov0" title="0">{
        sqlStatement := `
        SELECT WHERE 1=0`
        _, err := db.Query(sqlStatement)
        return err
}</span>

func (db *DB) Insert(ctx context.Context, d dto.DMS) (string, error) <span class="cov0" title="0">{
        db.logger = ctx.Value(utils.LamassuLoggerContextKey).(log.Logger)
        parentSpan := opentracing.SpanFromContext(ctx)
        var id string
        sqlStatement := `
        INSERT INTO dms_store(id,name, serialNumber, keyType, keyBits, csrBase64, status, creation_ts, modification_ts)
        VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING id;
        `
        span := opentracing.StartSpan("lamassu-dms-enroller: insert DMS with name "+d.Name+" in database", opentracing.ChildOf(parentSpan.Context()))
        err := db.QueryRow(sqlStatement, d.Id, d.Name, d.SerialNumber, d.KeyMetadata.KeyType, d.KeyMetadata.KeyBits, d.CsrBase64, d.Status, time.Now(), time.Now()).Scan(&amp;id)
        span.Finish()
        if err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err, "msg", "Could not insert DMS with name "+d.Name+" in database")
                duplicationErr := &amp;dmserrors.DuplicateResourceError{
                        ResourceType: "DMS",
                        ResourceId:   id,
                }
                return "", duplicationErr
        }</span>
        <span class="cov0" title="0">level.Debug(db.logger).Log("msg", "DMS with ID "+id+" inserted in database")
        return id, nil</span>
}

func (db *DB) SelectAll(ctx context.Context) ([]dto.DMS, error) <span class="cov0" title="0">{
        db.logger = ctx.Value(utils.LamassuLoggerContextKey).(log.Logger)
        parentSpan := opentracing.SpanFromContext(ctx)
        sqlStatement := `
        SELECT * 
        FROM dms_store;
        `
        span := opentracing.StartSpan("lamassu-dms-enroller: obtain DMSs from database", opentracing.ChildOf(parentSpan.Context()))
        rows, err := db.Query(sqlStatement)
        if err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err, "msg", "Could not obtain DMSs from database or the database is empty")
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "DMS",
                        ResourceId:   "Database is empty",
                }
                return []dto.DMS{}, notFoundErr
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        dmss := make([]dto.DMS, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                var d dto.DMS
                err := rows.Scan(&amp;d.Id, &amp;d.Name, &amp;d.SerialNumber, &amp;d.KeyMetadata.KeyType, &amp;d.KeyMetadata.KeyBits, &amp;d.CsrBase64, &amp;d.Status, &amp;d.CreationTimestamp, &amp;d.ModificationTimestamp)
                if err != nil </span><span class="cov0" title="0">{
                        return []dto.DMS{}, err
                }</span>
                <span class="cov0" title="0">d.KeyMetadata.KeyStrength = getKeyStrength(d.KeyMetadata.KeyType, d.KeyMetadata.KeyBits)

                //Get Enrolled_Devices per dms_id
                /*var length int
                sqlStatement1 := `
                SELECT COUNT(*) as count FROM device_information where dms_id = $1 and status &lt;&gt; 'PENDING_PROVISION'
                `
                //Count all devices which have status != PENDING_PROVISION
                rows, err := db.Query(sqlStatement1, d.Id)
                rows.Next()
                err = rows.Scan(&amp;length)


                if err != nil {
                        level.Debug(db.logger).Log("err", err, "msg", "Could not obtain Device "+d.Id+" from database")
                        d.EnrolledDevices = 0
                }
                d.EnrolledDevices = length*/
                span.Finish()
                dmss = append(dmss, d)</span>
        }
        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err)
                return []dto.DMS{}, err
        }</span>
        <span class="cov0" title="0">level.Debug(db.logger).Log("msg", strconv.Itoa(len(dmss))+" DMSs read from database")
        return dmss, nil</span>
}

func (db *DB) SelectByID(ctx context.Context, id string) (dto.DMS, error) <span class="cov0" title="0">{
        db.logger = ctx.Value(utils.LamassuLoggerContextKey).(log.Logger)
        parentSpan := opentracing.SpanFromContext(ctx)
        sqlStatement := `
        SELECT *
        FROM dms_store
        WHERE id = $1;
        `
        span := opentracing.StartSpan("lamassu-dms-enroller: obtain DMS with ID "+id+" from database", opentracing.ChildOf(parentSpan.Context()))
        row := db.QueryRow(sqlStatement, id)
        var d dto.DMS
        err := row.Scan(&amp;d.Id, &amp;d.Name, &amp;d.SerialNumber, &amp;d.KeyMetadata.KeyType, &amp;d.KeyMetadata.KeyBits, &amp;d.CsrBase64, &amp;d.Status, &amp;d.CreationTimestamp, &amp;d.ModificationTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "DMS",
                        ResourceId:   id,
                }
                return dto.DMS{}, notFoundErr
        }</span>
        <span class="cov0" title="0">span.Finish()
        d.KeyMetadata.KeyStrength = getKeyStrength(d.KeyMetadata.KeyType, d.KeyMetadata.KeyBits)

        level.Debug(db.logger).Log("msg", "DMS with ID "+id+" obtained from database")
        return d, nil</span>
}

func (db *DB) SelectBySerialNumber(ctx context.Context, SerialNumber string) (string, error) <span class="cov0" title="0">{
        parentSpan := opentracing.SpanFromContext(ctx)
        sqlStatement := `
        SELECT *
        FROM dms_store
        WHERE serialNumber = $1;
        `
        span := opentracing.StartSpan("lamassu-dms-enroller: obtain DMS with SerialNumber "+SerialNumber+" from database", opentracing.ChildOf(parentSpan.Context()))
        row, err := db.Query(sqlStatement, SerialNumber)
        if err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err, "msg", "Could not obtain DMS")
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "DMS",
                        ResourceId:   SerialNumber,
                }
                return "", notFoundErr
        }</span>
        <span class="cov0" title="0">span.Finish()
        defer row.Close()
        var d dto.DMS
        for row.Next() </span><span class="cov0" title="0">{

                err = row.Scan(&amp;d.Id, &amp;d.Name, &amp;d.SerialNumber, &amp;d.KeyMetadata.KeyType, &amp;d.KeyMetadata.KeyBits, &amp;d.CsrBase64, &amp;d.Status, &amp;d.CreationTimestamp, &amp;d.ModificationTimestamp)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">return d.Id, nil</span>
}

func (db *DB) UpdateByID(ctx context.Context, id string, status string, serialNumber string, encodedCsr string) (dto.DMS, error) <span class="cov0" title="0">{
        db.logger = ctx.Value(utils.LamassuLoggerContextKey).(log.Logger)
        parentSpan := opentracing.SpanFromContext(ctx)
        sqlStatement := `
        UPDATE dms_store
        SET status = $1, serialNumber = $2, csrBase64 = $3, modification_ts = $4
        WHERE id = $5;
        `
        span := opentracing.StartSpan("lamassu-dms-enroller: update DMS with ID "+id+" status to "+status, opentracing.ChildOf(parentSpan.Context()))
        res, err := db.Exec(sqlStatement, status, serialNumber, encodedCsr, time.Now(), id)
        span.Finish()
        if err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err, "msg", "Could not update DMS with ID "+id+" status to "+status)
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "DMS",
                        ResourceId:   id,
                }
                return dto.DMS{}, notFoundErr
        }</span>
        <span class="cov0" title="0">count, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return dto.DMS{}, err
        }</span>
        <span class="cov0" title="0">if count &lt;= 0 </span><span class="cov0" title="0">{
                err = errors.New("No rows have been updated in database")
                level.Debug(db.logger).Log("err", err)
                return dto.DMS{}, err
        }</span>
        <span class="cov0" title="0">level.Debug(db.logger).Log("msg", "DMS with ID "+id+" status updated to"+status)
        return db.SelectByID(ctx, id)</span>
}

func (db *DB) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        db.logger = ctx.Value(utils.LamassuLoggerContextKey).(log.Logger)
        parentSpan := opentracing.SpanFromContext(ctx)
        sqlStatement := `
        DELETE FROM dms_store
        WHERE id = $1;
        `
        span := opentracing.StartSpan("delete DMS with ID "+id+" from database", opentracing.ChildOf(parentSpan.Context()))
        res, err := db.Exec(sqlStatement, id)
        span.Finish()
        if err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err, "msg", "Could not delete DMS with ID "+id+" from database")
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "DMS",
                        ResourceId:   id,
                }
                return notFoundErr
        }</span>
        <span class="cov0" title="0">count, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if count &lt;= 0 </span><span class="cov0" title="0">{
                err = errors.New("no rows have been updated in database")
                level.Debug(db.logger).Log("err", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (db *DB) InsertAuthorizedCAs(ctx context.Context, dmsid string, CAs []string) error <span class="cov0" title="0">{
        db.logger = ctx.Value(utils.LamassuLoggerContextKey).(log.Logger)
        parentSpan := opentracing.SpanFromContext(ctx)
        for i := 0; i &lt; len(CAs); i++ </span><span class="cov0" title="0">{
                sqlStatement := `
                INSERT INTO authorized_cas(dmsid,caname)
                VALUES($1,$2)
                RETURNING dmsid;
                `
                span := opentracing.StartSpan("lamassu-dms-enroller: insert Authorized CA with name "+CAs[i]+" in authorized_cas database", opentracing.ChildOf(parentSpan.Context()))
                err := db.QueryRow(sqlStatement, dmsid, CAs[i]).Scan(&amp;dmsid)
                span.Finish()
                if err != nil </span><span class="cov0" title="0">{
                        level.Debug(db.logger).Log("err", err, "msg", "Could not insert CA with name "+CAs[i]+" in authorized_cas database")
                        duplicationErr := &amp;dmserrors.DuplicateResourceError{
                                ResourceType: "DMS",
                                ResourceId:   dmsid,
                        }
                        return duplicationErr
                }</span>
        }
        <span class="cov0" title="0">level.Debug(db.logger).Log("msg", "DMS with ID "+dmsid+" inserted in authorized_cas database")
        return nil</span>
}
func (db *DB) DeleteAuthorizedCAs(ctx context.Context, dmsid string) error <span class="cov0" title="0">{
        db.logger = ctx.Value(utils.LamassuLoggerContextKey).(log.Logger)
        parentSpan := opentracing.SpanFromContext(ctx)
        sqlStatement := `
        DELETE FROM authorized_cas
        WHERE dmsid = $1;
        `
        span := opentracing.StartSpan("lamassu-dms-enroller: delete DMS with ID "+dmsid+" from authorized_cas database", opentracing.ChildOf(parentSpan.Context()))
        res, err := db.Exec(sqlStatement, dmsid)
        span.Finish()
        if err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err, "msg", "Could not delete DMS with ID "+dmsid+" in authorized_cas database")
                return err
        }</span>
        <span class="cov0" title="0">count, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if count &lt;= 0 </span><span class="cov0" title="0">{
                err = errors.New("no rows have been updated in database")
                level.Debug(db.logger).Log("err", err)
                return err
        }</span>
        <span class="cov0" title="0">level.Debug(db.logger).Log("msg", "DMS with ID "+dmsid+" deleted in authorized_cas database")
        return nil</span>
}

func (db *DB) SelectByDMSIDAuthorizedCAs(ctx context.Context, dmsid string) ([]dms.AuthorizedCAs, error) <span class="cov0" title="0">{
        parentSpan := opentracing.SpanFromContext(ctx)
        sqlStatement := `
        SELECT * 
        FROM authorized_cas
        WHERE dmsid = $1;
        `
        span := opentracing.StartSpan("lamassu-dms-enroller: obtain Authorized CAs with DMS ID"+dmsid+"from database", opentracing.ChildOf(parentSpan.Context()))
        rows, err := db.Query(sqlStatement, dmsid)
        span.Finish()
        if err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err, "msg", "Could not obtain DMSs from database or the database is empty")
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        cass := make([]dms.AuthorizedCAs, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                var d dms.AuthorizedCAs
                err := rows.Scan(&amp;d.DmsId, &amp;d.CaName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">cass = append(cass, d)</span>
        }
        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return cass, nil</span>
}
func (db *DB) SelectAllAuthorizedCAs(ctx context.Context) ([]dms.AuthorizedCAs, error) <span class="cov0" title="0">{
        db.logger = ctx.Value(utils.LamassuLoggerContextKey).(log.Logger)
        parentSpan := opentracing.SpanFromContext(ctx)
        sqlStatement := `
        SELECT * 
        FROM authorized_cas;
        `
        span := opentracing.StartSpan("lamassu-dms-enroller: obtain authorized CAs from database", opentracing.ChildOf(parentSpan.Context()))
        rows, err := db.Query(sqlStatement)
        span.Finish()
        if err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err, "msg", "Could not obtain authorized CAs from database or the database is empty")
                return []dms.AuthorizedCAs{}, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        dmss := make([]dms.AuthorizedCAs, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                var d dms.AuthorizedCAs
                err := rows.Scan(&amp;d.DmsId, &amp;d.CaName)
                if err != nil </span><span class="cov0" title="0">{
                        return []dms.AuthorizedCAs{}, err
                }</span>
                <span class="cov0" title="0">dmss = append(dmss, d)</span>
        }
        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err)
                return []dms.AuthorizedCAs{}, err
        }</span>
        <span class="cov0" title="0">level.Debug(db.logger).Log("msg", strconv.Itoa(len(dmss))+" DMSs read from database")

        return dmss, nil</span>
}

func (db *DB) CountEnrolledDevices(ctx context.Context, dms_id string) (int, error) <span class="cov0" title="0">{
        db.logger = ctx.Value(utils.LamassuLoggerContextKey).(log.Logger)
        var length int
        parentSpan := opentracing.SpanFromContext(ctx)
        sqlStatement1 := `
                SELECT COUNT(*) as count FROM device_information where dms_id = $1 and status &lt;&gt; $2
                `
        span := opentracing.StartSpan("lamassu-device-manager: Count Devices by DMS "+dms_id+" from database", opentracing.ChildOf(parentSpan.Context()))

        err := db.QueryRow(sqlStatement1, dms_id, "PENDING_PROVISION").Scan(
                &amp;length,
        )

        span.Finish()
        if err != nil </span><span class="cov0" title="0">{
                level.Debug(db.logger).Log("err", err, "msg", "Could not obtain Device "+dms_id+" from database")
                notFoundErr := &amp;dmserrors.ResourceNotFoundError{
                        ResourceType: "DMS",
                        ResourceId:   dms_id,
                }
                return 0, notFoundErr
        }</span>

        <span class="cov0" title="0">return length, nil</span>

}

func getKeyStrength(keyType string, keyBits int) string <span class="cov0" title="0">{
        var keyStrength string = "unknown"
        switch keyType </span>{
        case "RSA":<span class="cov0" title="0">
                if keyBits &lt; 2048 </span><span class="cov0" title="0">{
                        keyStrength = "low"
                }</span> else<span class="cov0" title="0"> if keyBits &gt;= 2048 &amp;&amp; keyBits &lt; 3072 </span><span class="cov0" title="0">{
                        keyStrength = "medium"
                }</span> else<span class="cov0" title="0"> {
                        keyStrength = "high"
                }</span>
        case "EC":<span class="cov0" title="0">
                if keyBits &lt; 224 </span><span class="cov0" title="0">{
                        keyStrength = "low"
                }</span> else<span class="cov0" title="0"> if keyBits &gt;= 224 &amp;&amp; keyBits &lt; 256 </span><span class="cov0" title="0">{
                        keyStrength = "medium"
                }</span> else<span class="cov0" title="0"> {
                        keyStrength = "high"
                }</span>
        }
        <span class="cov0" title="0">return keyStrength</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
